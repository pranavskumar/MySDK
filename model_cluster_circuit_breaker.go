/*
F5 Distributed Cloud Services API for ves.io.schema.views.origin_pool

Origin pool is a view to create cluster and endpoints that can be used in HTTP loadbalancer or TCP loadbalancer  It will create following child objects  * cluster * endpoints * healthcheck

API version: 
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
)

// checks if the ClusterCircuitBreaker type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &ClusterCircuitBreaker{}

// ClusterCircuitBreaker CircuitBreaker provides a mechanism for watching failures in upstream connections or requests and if the failures reach a certain threshold, automatically fail subsequent requests which allows to apply back pressure on downstream quickly.
type ClusterCircuitBreaker struct {
	//  The maximum number of connections that loadbalancer will establish to all hosts in an upstream cluster.  In practice this is only applicable to TCP and HTTP/1.1 clusters since HTTP/2 uses a single connection to each host.  Remove endpoint out of load balancing decision, if number of connections reach connection limit.  Example: ` \"100\"`  Validation Rules:   ves.io.schema.rules.uint32.lte: 32768 
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`
	//  The maximum number of requests that can be outstanding to all hosts in a cluster at any given time.  In practice this is applicable to HTTP/2 clusters since HTTP/1.1 clusters are governed by the  maximum connections (connection_limit).  Remove endpoint out of load balancing decision, if requests exceed this count.  Example: ` \"10\"`  Validation Rules:   ves.io.schema.rules.uint32.lte: 32768 
	MaxRequests *int64 `json:"max_requests,omitempty"`
	//  The maximum number of requests that will be queued while waiting for a ready connection pool connection.  Since HTTP/2 requests are sent over a single connection, this circuit breaker only comes into play as the  initial connection is created, as requests will be multiplexed immediately afterwards. For HTTP/1.1, requests  are added to the list of pending requests whenever there arenâ€™t enough upstream connections available to  immediately dispatch the request, so this circuit breaker will remain in play for the lifetime of the process.  Remove endpoint out of load balancing decision, if pending request reach  pending_request.  Example: ` \"20\"`  Validation Rules:   ves.io.schema.rules.uint32.lte: 32768 
	PendingRequests *int64 `json:"pending_requests,omitempty"`
	Priority *SchemaRoutingPriority `json:"priority,omitempty"`
	//  The maximum number of retries that can be outstanding to all hosts in a cluster at any given time.  Remove endpoint out of load balancing decision, if retries for request exceed this count.  Example: ` \"10\"`  Validation Rules:   ves.io.schema.rules.uint32.lte: 32768 
	Retries *int64 `json:"retries,omitempty"`
}

// NewClusterCircuitBreaker instantiates a new ClusterCircuitBreaker object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewClusterCircuitBreaker() *ClusterCircuitBreaker {
	this := ClusterCircuitBreaker{}
	var priority SchemaRoutingPriority = DEFAULT
	this.Priority = &priority
	return &this
}

// NewClusterCircuitBreakerWithDefaults instantiates a new ClusterCircuitBreaker object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewClusterCircuitBreakerWithDefaults() *ClusterCircuitBreaker {
	this := ClusterCircuitBreaker{}
	var priority SchemaRoutingPriority = DEFAULT
	this.Priority = &priority
	return &this
}

// GetConnectionLimit returns the ConnectionLimit field value if set, zero value otherwise.
func (o *ClusterCircuitBreaker) GetConnectionLimit() int64 {
	if o == nil || IsNil(o.ConnectionLimit) {
		var ret int64
		return ret
	}
	return *o.ConnectionLimit
}

// GetConnectionLimitOk returns a tuple with the ConnectionLimit field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ClusterCircuitBreaker) GetConnectionLimitOk() (*int64, bool) {
	if o == nil || IsNil(o.ConnectionLimit) {
		return nil, false
	}
	return o.ConnectionLimit, true
}

// HasConnectionLimit returns a boolean if a field has been set.
func (o *ClusterCircuitBreaker) HasConnectionLimit() bool {
	if o != nil && !IsNil(o.ConnectionLimit) {
		return true
	}

	return false
}

// SetConnectionLimit gets a reference to the given int64 and assigns it to the ConnectionLimit field.
func (o *ClusterCircuitBreaker) SetConnectionLimit(v int64) {
	o.ConnectionLimit = &v
}

// GetMaxRequests returns the MaxRequests field value if set, zero value otherwise.
func (o *ClusterCircuitBreaker) GetMaxRequests() int64 {
	if o == nil || IsNil(o.MaxRequests) {
		var ret int64
		return ret
	}
	return *o.MaxRequests
}

// GetMaxRequestsOk returns a tuple with the MaxRequests field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ClusterCircuitBreaker) GetMaxRequestsOk() (*int64, bool) {
	if o == nil || IsNil(o.MaxRequests) {
		return nil, false
	}
	return o.MaxRequests, true
}

// HasMaxRequests returns a boolean if a field has been set.
func (o *ClusterCircuitBreaker) HasMaxRequests() bool {
	if o != nil && !IsNil(o.MaxRequests) {
		return true
	}

	return false
}

// SetMaxRequests gets a reference to the given int64 and assigns it to the MaxRequests field.
func (o *ClusterCircuitBreaker) SetMaxRequests(v int64) {
	o.MaxRequests = &v
}

// GetPendingRequests returns the PendingRequests field value if set, zero value otherwise.
func (o *ClusterCircuitBreaker) GetPendingRequests() int64 {
	if o == nil || IsNil(o.PendingRequests) {
		var ret int64
		return ret
	}
	return *o.PendingRequests
}

// GetPendingRequestsOk returns a tuple with the PendingRequests field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ClusterCircuitBreaker) GetPendingRequestsOk() (*int64, bool) {
	if o == nil || IsNil(o.PendingRequests) {
		return nil, false
	}
	return o.PendingRequests, true
}

// HasPendingRequests returns a boolean if a field has been set.
func (o *ClusterCircuitBreaker) HasPendingRequests() bool {
	if o != nil && !IsNil(o.PendingRequests) {
		return true
	}

	return false
}

// SetPendingRequests gets a reference to the given int64 and assigns it to the PendingRequests field.
func (o *ClusterCircuitBreaker) SetPendingRequests(v int64) {
	o.PendingRequests = &v
}

// GetPriority returns the Priority field value if set, zero value otherwise.
func (o *ClusterCircuitBreaker) GetPriority() SchemaRoutingPriority {
	if o == nil || IsNil(o.Priority) {
		var ret SchemaRoutingPriority
		return ret
	}
	return *o.Priority
}

// GetPriorityOk returns a tuple with the Priority field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ClusterCircuitBreaker) GetPriorityOk() (*SchemaRoutingPriority, bool) {
	if o == nil || IsNil(o.Priority) {
		return nil, false
	}
	return o.Priority, true
}

// HasPriority returns a boolean if a field has been set.
func (o *ClusterCircuitBreaker) HasPriority() bool {
	if o != nil && !IsNil(o.Priority) {
		return true
	}

	return false
}

// SetPriority gets a reference to the given SchemaRoutingPriority and assigns it to the Priority field.
func (o *ClusterCircuitBreaker) SetPriority(v SchemaRoutingPriority) {
	o.Priority = &v
}

// GetRetries returns the Retries field value if set, zero value otherwise.
func (o *ClusterCircuitBreaker) GetRetries() int64 {
	if o == nil || IsNil(o.Retries) {
		var ret int64
		return ret
	}
	return *o.Retries
}

// GetRetriesOk returns a tuple with the Retries field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ClusterCircuitBreaker) GetRetriesOk() (*int64, bool) {
	if o == nil || IsNil(o.Retries) {
		return nil, false
	}
	return o.Retries, true
}

// HasRetries returns a boolean if a field has been set.
func (o *ClusterCircuitBreaker) HasRetries() bool {
	if o != nil && !IsNil(o.Retries) {
		return true
	}

	return false
}

// SetRetries gets a reference to the given int64 and assigns it to the Retries field.
func (o *ClusterCircuitBreaker) SetRetries(v int64) {
	o.Retries = &v
}

func (o ClusterCircuitBreaker) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o ClusterCircuitBreaker) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.ConnectionLimit) {
		toSerialize["connection_limit"] = o.ConnectionLimit
	}
	if !IsNil(o.MaxRequests) {
		toSerialize["max_requests"] = o.MaxRequests
	}
	if !IsNil(o.PendingRequests) {
		toSerialize["pending_requests"] = o.PendingRequests
	}
	if !IsNil(o.Priority) {
		toSerialize["priority"] = o.Priority
	}
	if !IsNil(o.Retries) {
		toSerialize["retries"] = o.Retries
	}
	return toSerialize, nil
}

type NullableClusterCircuitBreaker struct {
	value *ClusterCircuitBreaker
	isSet bool
}

func (v NullableClusterCircuitBreaker) Get() *ClusterCircuitBreaker {
	return v.value
}

func (v *NullableClusterCircuitBreaker) Set(val *ClusterCircuitBreaker) {
	v.value = val
	v.isSet = true
}

func (v NullableClusterCircuitBreaker) IsSet() bool {
	return v.isSet
}

func (v *NullableClusterCircuitBreaker) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableClusterCircuitBreaker(val *ClusterCircuitBreaker) *NullableClusterCircuitBreaker {
	return &NullableClusterCircuitBreaker{value: val, isSet: true}
}

func (v NullableClusterCircuitBreaker) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableClusterCircuitBreaker) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


