//go:build go1.18
// +build go1.18

// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/go@4.0.0-preview.63)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// Code generated by @autorest/go. DO NOT EDIT.

package generated

import "time"

// ClusterCircuitBreaker - CircuitBreaker provides a mechanism for watching failures in upstream connections or requests and
// if the failures reach a certain threshold, automatically fail subsequent requests which allows to
// apply back pressure on downstream quickly.
type ClusterCircuitBreaker struct {
	// The maximum number of connections that loadbalancer will establish to all hosts in an upstream cluster. In practice this
// is only applicable to TCP and HTTP/1.1 clusters since HTTP/2 uses a single
// connection to each host. Remove endpoint out of load balancing decision, if number of connections reach connection limit.
// Example: "100"
// Validation Rules: ves.io.schema.rules.uint32.lte: 32768
	ConnectionLimit *int64

	// The maximum number of requests that can be outstanding to all hosts in a cluster at any given time. In practice this is
// applicable to HTTP/2 clusters since HTTP/1.1 clusters are governed by the
// maximum connections (connection_limit). Remove endpoint out of load balancing decision, if requests exceed this count.
// Example: "10"
// Validation Rules: ves.io.schema.rules.uint32.lte: 32768
	MaxRequests *int64

	// The maximum number of requests that will be queued while waiting for a ready connection pool connection. Since HTTP/2 requests
// are sent over a single connection, this circuit breaker only comes into
// play as the initial connection is created, as requests will be multiplexed immediately afterwards. For HTTP/1.1, requests
// are added to the list of pending requests whenever there aren’t enough
// upstream connections available to immediately dispatch the request, so this circuit breaker will remain in play for the
// lifetime of the process. Remove endpoint out of load balancing decision, if
// pending request reach pending_request.
// Example: "20"
// Validation Rules: ves.io.schema.rules.uint32.lte: 32768
	PendingRequests *int64

	// Priority routing for each request. Different connection pools are used based on the priority selected for the request.
// Also, circuit-breaker configuration at destination cluster is chosen based on
// selected priority.
// Default routing mechanism High-Priority routing mechanism
	Priority *SchemaRoutingPriority

	// The maximum number of retries that can be outstanding to all hosts in a cluster at any given time. Remove endpoint out
// of load balancing decision, if retries for request exceed this count.
// Example: "10"
// Validation Rules: ves.io.schema.rules.uint32.lte: 32768
	Retries *int64
}

// ClusterEndpointSubsetSelectorType - Upstream cluster may be configured to divide its endpoints into subsets based on metadata
// attached to the endpoints. Routes may then specify the metadata that a endpoint must match in order to be
// selected by the load balancer. List of keys that define a cluster subset. Each endpoint that has a metadata value for all
// of the keys in the definition is added to that subset. If no endpoint has all
// the keys, no subsets result from the definition. A single endpoint may appear in multiple subsets if it matches multiple
// definitions.
type ClusterEndpointSubsetSelectorType struct {
	// List of keys that define a cluster subset class.
// Example: "production"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.repeated.items.string.notempty: true ves.io.schema.rules.repeated.maxitems:
// 16
	Keys any
}

// ClusterHTTP2ProtocolOptions - Http2 Protocol options for upstream connections
type ClusterHTTP2ProtocolOptions struct {
	// Enable/disable HTTP2 Protocol for upstream connections
	Enabled *bool
}

// ClusterOutlierDetectionType - Outlier detection and ejection is the process of dynamically determining whether some number
// of hosts in an upstream cluster are performing unlike the others and removing them from the healthy load
// balancing set. Outlier detection is a form of passive health checking.
// Algorithm
// 1. A endpoint is determined to be an outlier (based on configured number of consecutive5xx or consecutivegateway_failures)
// .
// 2. If no endpoints have been ejected, loadbalancer will eject the host immediately. Otherwise, it checks to make sure the
// number of ejected hosts is below the allowed threshold (specified via max
// ejectionpercent setting). If the number of ejected hosts is above the threshold, the host is not ejected.
// 3. The endpoint is ejected for some number of milliseconds. Ejection means that the endpoint is marked unhealthy and will
// not be used during load balancing. The number of milliseconds is equal to the
// baseejectiontime value multiplied by the number of times the host has been ejected.
// 4. An ejected endpoint will automatically be brought back into service after the ejection time has been satisfied
type ClusterOutlierDetectionType struct {
	// The base time that a host is ejected for. The real time is equal to the base time multiplied by the number of times the
// host has been ejected. This causes hosts to get ejected for longer periods if
// they continue to fail. Defaults to 30000ms or 30s. Specified in milliseconds.
// Example: "20000"
// Validation Rules: ves.io.schema.rules.uint32.lte: 1800000
	BaseEjectionTime *int64

	// If an upstream endpoint returns some number of consecutive 5xx, it will be ejected. Note that in this case a 5xx means
// an actual 5xx respond code, or an event that would cause the HTTP router to
// return one on the upstream’s behalf(reset, connection failure, etc.) consecutive_5xx indicates the number of consecutive
// 5xx responses required before a consecutive 5xx ejection occurs. Defaults to 5.
// Example: "3"
// Validation Rules: ves.io.schema.rules.uint32.lte: 1024
	Consecutive5Xx *int64

	// If an upstream endpoint returns some number of consecutive “gateway errors” (502, 503 or 504 status code), it will be ejected.
// Note that this includes events that would cause the HTTP router to return
// one of these status codes on the upstream’s behalf (reset, connection failure, etc.). consecutivegatewayfailure indicates
// the number of consecutive gateway failures before a consecutive gateway
// failure ejection occurs. Defaults to 5.
// Example: "5"
// Validation Rules: ves.io.schema.rules.uint32.lte: 1024
	ConsecutiveGatewayFailure *int64

	// The time interval between ejection analysis sweeps. This can result in both new ejections as well as endpoints being returned
// to service. Defaults to 10000ms or 10s. Specified in milliseconds.
// Example: "5000"
// Validation Rules: ves.io.schema.rules.uint32.lte: 600000
	Interval *int64

	// The maximum % of an upstream cluster that can be ejected due to outlier detection. Defaults to 10% but will eject at least
// one host regardless of the value.
// Example: "20"
// Validation Rules: ves.io.schema.rules.uint32.lte: 100
	MaxEjectionPercent *int64
}

// IoschemaObjectRefType - This type establishes a 'direct reference' from one object(the referrer) to another(the referred).
// Such a reference is in form of tenant/namespace/name for public API and Uid for private API This type
// of reference is called direct because the relation is explicit and concrete (as opposed to selector reference which builds
// a group based on labels of selectee objects)
type IoschemaObjectRefType struct {
	// When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind
// (e.g. "route")
// Example: "virtual_site"
	Kind *string

	// When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g.
// route's) name.
// Example: "contactus-route"
	Name *string

	// When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g.
// route's) namespace.
// Example: "ns1"
	Namespace *string

	// When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g.
// route's) tenant.
// Example: "acmecorp"
	Tenant *string

	// When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g.
// route's) uid.
// Example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	UID *string
}

// OriginPoolAdvancedOptions - Configure Advanced options for origin pool
type OriginPoolAdvancedOptions struct {
	// This can be used for messages where no values are needed
	AutoHTTPConfig any

	// CircuitBreaker provides a mechanism for watching failures in upstream connections or requests and if the failures reach
// a certain threshold, automatically fail subsequent requests which allows to
// apply back pressure on downstream quickly.
	CircuitBreaker *ClusterCircuitBreaker

	// The timeout for new network connections to endpoints in the cluster. This is specified in milliseconds. The default value
// is 2 seconds
// Example: "4000"
// Validation Rules: ves.io.schema.rules.uint32.lte: 1800000
	ConnectionTimeout *int64

	// This can be used for messages where no values are needed
	DefaultCircuitBreaker any

	// This can be used for messages where no values are needed
	DisableCircuitBreaker any

	// This can be used for messages where no values are needed
	DisableOutlierDetection any

	// This can be used for messages where no values are needed
	DisableSubsets any

	// Configure subset options for origin pool
	EnableSubsets *OriginPoolSubsets

	// This can be used for messages where no values are needed
	HTTP1Config any

	// Http2 Protocol options for upstream connections
	HTTP2Options *ClusterHTTP2ProtocolOptions

	// The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are
// no active requests. When the idle timeout is reached the connection will be
// closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in
// milliseconds. The default value is 5 minutes.
// Example: "60000"
// Validation Rules: ves.io.schema.rules.uint32.lte: 600000
	HTTPIdleTimeout *int64

	// Header Transformation options for HTTP/1.1 request/response headers
	HeaderTransformationType *SchemaHeaderTransformationType

	// This can be used for messages where no values are needed
	NoPanicThreshold any

	// Outlier detection and ejection is the process of dynamically determining whether some number of hosts in an upstream cluster
// are performing unlike the others and removing them from the healthy load
// balancing set. Outlier detection is a form of passive health checking.
// Algorithm
// 1. A endpoint is determined to be an outlier (based on configured number of consecutive5xx or consecutivegateway_failures)
// .
// 2. If no endpoints have been ejected, loadbalancer will eject the host immediately. Otherwise, it checks to make sure the
// number of ejected hosts is below the allowed threshold (specified via max
// ejectionpercent setting). If the number of ejected hosts is above the threshold, the host is not ejected.
// 3. The endpoint is ejected for some number of milliseconds. Ejection means that the endpoint is marked unhealthy and will
// not be used during load balancing. The number of milliseconds is equal to the
// baseejectiontime value multiplied by the number of times the host has been ejected.
// 4. An ejected endpoint will automatically be brought back into service after the ejection time has been satisfied
	OutlierDetection *ClusterOutlierDetectionType

	// Exclusive with [nopanicthreshold] x-example:"25" Configure a threshold (percentage of unhealthy endpoints) below which
// all endpoints will be considered for load balancing ignoring its health status.
// Validation Rules: ves.io.schema.rules.uint32.lte: 100
	PanicThreshold *int64
}

// OriginPoolCreateRequest - This is the input message of the 'Create' RPC
type OriginPoolCreateRequest struct {
	// ObjectCreateMetaType is metadata that can be specified in Create request of an object.
	Metadata *SchemaObjectCreateMetaType

	// Shape of the origin pool create specification
	Spec *ViewsoriginPoolCreateSpecType
}

type OriginPoolCreateResponse struct {
	// ObjectGetMetaType is metadata that can be specified in Get/Create response of an object.
	Metadata *SchemaObjectGetMetaType

	// Shape of the origin pool get specification
	Spec *ViewsoriginPoolGetSpecType

	// SystemObjectGetMetaType is metadata generated or populated by the system for all persisted objects and cannot be updated
// directly by users.
	SystemMetadata *SchemaSystemObjectGetMetaType
}

// OriginPoolDefaultSubset - Default Subset definition
type OriginPoolDefaultSubset struct {
	// List of key-value pairs that define default subset. which gets used when route specifies no metadata or no subset matching
// the metadata exists.
// Example: "key:value"
// Validation Rules: ves.io.schema.rules.map.max_pairs: 32
	DefaultSubset any
}

// OriginPoolDeleteRequest - This is the input message of the 'Delete' RPC.
type OriginPoolDeleteRequest struct {
	// Fail the delete operation if this object is being referred by other objects
	FailIfReferred *bool

	// Name of the configuration object
// Example: "name"
	Name *string

	// Namespace in which the configuration object is present
// Example: "ns1"
	Namespace *string
}

// OriginPoolGetResponse - This is the output message of the 'Get' RPC
type OriginPoolGetResponse struct {
	// This is the input message of the 'Create' RPC
	CreateForm *OriginPoolCreateRequest

	// The set of deleted objects that are referred by this object
	DeletedReferredObjects any

	// The set of deleted objects that are referred by this object
	DisabledReferredObjects any

	// ObjectGetMetaType is metadata that can be specified in Get/Create response of an object.
	Metadata *SchemaObjectGetMetaType

	// Origin pool view object
	Object *OriginPoolObject

	// The set of objects that are referring to this object in their spec
	ReferringObjects any

	// This is the input message of the 'Replace' RPC
	ReplaceForm *OriginPoolReplaceRequest

	// Shape of the origin pool get specification
	Spec *ViewsoriginPoolGetSpecType

	// SystemObjectGetMetaType is metadata generated or populated by the system for all persisted objects and cannot be updated
// directly by users.
	SystemMetadata *SchemaSystemObjectGetMetaType
}

// OriginPoolListResponse - This is the output message of 'List' RPC.
type OriginPoolListResponse struct {
	// Errors(if any) while listing items from collection
	Errors any

	// items represents the collection in response
	Items any
}

// OriginPoolListResponseItem - By default a summary of originpool is returned in 'List'. By setting 'reportfields' in the
// ListRequest more details of each item can be got.
type OriginPoolListResponseItem struct {
	// The set of annotations present on this origin_pool
	Annotations any

	// The description set for this origin_pool
	Description *string

	// A value of true indicates origin_pool is administratively disabled
	Disabled *bool

	// Shape of the origin pool get specification
	GetSpec *ViewsoriginPoolGetSpecType

	// The set of labels present on this origin_pool
	Labels any

	// ObjectGetMetaType is metadata that can be specified in Get/Create response of an object.
	Metadata *SchemaObjectGetMetaType

	// The name of this origin_pool
// Example: "name"
	Name *string

	// The namespace this item belongs to
// Example: "ns1"
	Namespace *string

	// Origin pool view object
	Object *OriginPoolObject

	// ViewRefType represents a reference to a view
	OwnerView *SchemaViewRefType

	// SystemObjectGetMetaType is metadata generated or populated by the system for all persisted objects and cannot be updated
// directly by users.
	SystemMetadata *SchemaSystemObjectGetMetaType

	// The tenant this item belongs to
// Example: "acmecorp"
	Tenant *string

	// The unique uid of this origin_pool
// Example: "d27938ba-967e-40a7-9709-57b8627f9f75"
	UID *string
}

// OriginPoolObject - Origin pool view object
type OriginPoolObject struct {
	// ObjectMetaType is metadata(common attributes) of an object that all configuration objects will have. The information in
// this type can be specified by user during create and replace APIs.
	Metadata *SchemaObjectMetaType
	Spec *OriginPoolSpecType

	// SystemObjectMetaType is metadata generated or populated by the system for all persisted objects and cannot be updated directly
// by users.
	SystemMetadata *SchemaSystemObjectMetaType
}

// OriginPoolOriginServerConsulService - Specify origin server with Hashi Corp Consul service name and site information
type OriginPoolOriginServerConsulService struct {
	// This can be used for messages where no values are needed
	InsideNetwork any

	// This can be used for messages where no values are needed
	OutsideNetwork any

	// Consul service name of this origin server, including cluster-id. The format is servicename:cluster-id. If the servicename
// is "frontend", and cluster-id is "prod", then you will enter "frontend:prod".
// cluster-id is optional.
// Example: "matching:production"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true
	ServiceName *string

	// This message defines a reference to a site or virtual site object
	SiteLocator *ViewsSiteLocator
}

// OriginPoolOriginServerCustomEndpoint - Specify origin server with a reference to endpoint object
type OriginPoolOriginServerCustomEndpoint struct {
	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	Endpoint *SchemaviewsObjectRefType
}

// OriginPoolOriginServerK8SService - Specify origin server with K8s service name and site information
type OriginPoolOriginServerK8SService struct {
	// This can be used for messages where no values are needed
	InsideNetwork any

	// This can be used for messages where no values are needed
	OutsideNetwork any

	// Exclusive with [] K8s service name of the origin server, including the namespace and cluster-id The format is servicename.namespace:cluster-id.
// If the servicename is "frontend", namespace is
// "speedtest" and cluster-id is "prod", then you will enter "frontend.speedtest:prod". Both namespace and cluster-id are
// optional.
// Example: "matching.default:production"
// Validation Rules: ves.io.schema.rules.string.vesservicenamespace_name: true
	ServiceName *string

	// This message defines a reference to a site or virtual site object
	SiteLocator *ViewsSiteLocator

	// This can be used for messages where no values are needed
	Vk8SNetworks any
}

// OriginPoolOriginServerPrivateIP - Specify origin server with private or public IP address and site information
type OriginPoolOriginServerPrivateIP struct {
	// Exclusive with [] Private IPV4 address
// Example: "8.8.8.8"
// Validation Rules: ves.io.schema.rules.string.ipv4: true
	IP *string

	// This can be used for messages where no values are needed
	InsideNetwork any

	// This can be used for messages where no values are needed
	OutsideNetwork any

	// This message defines a reference to a site or virtual site object
	SiteLocator *ViewsSiteLocator
}

// OriginPoolOriginServerPrivateName - Specify origin server with private or public DNS name and site information
type OriginPoolOriginServerPrivateName struct {
	// DNS Name
// Example: "value"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true
	DNSName *string

	// This can be used for messages where no values are needed
	InsideNetwork any

	// This can be used for messages where no values are needed
	OutsideNetwork any

	// Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/html/rfc8767
// Example: "20"
// Validation Rules: ves.io.schema.rules.uint32.lte: 604800
	RefreshInterval *int64

	// This message defines a reference to a site or virtual site object
	SiteLocator *ViewsSiteLocator
}

// OriginPoolOriginServerPublicIP - Specify origin server with public IP address
type OriginPoolOriginServerPublicIP struct {
	// Exclusive with [] Public IPV4 address
// Example: "8.8.8.8"
// Validation Rules: ves.io.schema.rules.string.ipv4: true
	IP *string
}

// OriginPoolOriginServerPublicName - Specify origin server with public DNS name
type OriginPoolOriginServerPublicName struct {
	// DNS Name
// Example: "value"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.string.hostname: true ves.io.schema.rules.string.maxlen:
// 256 ves.io.schema.rules.string.minlen: 1
	DNSName *string

	// Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/html/rfc8767
// Example: "20"
// Validation Rules: ves.io.schema.rules.uint32.lte: 604800
	RefreshInterval *int64
}

// OriginPoolOriginServerSegmentIP - x-displayName: "IP address of Origin server in Segment on given Site" Specify origin
// server with IP address in a Segment on given Site
type OriginPoolOriginServerSegmentIP struct {
	// x-displayName: "IP" x-example: "8.8.8.8" Private IPV4 address
	IP *string

	// x-displayName: "IP6" x-example: "2001::10" Private IPV6 address
	IPv6 *string

	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	Segment *SchemaviewsObjectRefType

	// x-displayName: "Select Site or Virtual Site or Cloud Edge" This message defines reference to site or virtual site or a
// cloud-re-region object
	SiteLocator *ViewsSiteRegionLocator
}

// OriginPoolOriginServerSegmentName - x-displayName: "DNS Name of Origin Server in Segment on given Sites" Specify origin
// server with DNS name in Segment on given Site
type OriginPoolOriginServerSegmentName struct {
	// x-displayName: "DNS Name" x-example: "value" x-required DNS Name
	DNSName *string

	// x-displayName: "DNS Refresh interval" x-example: "20" Interval for DNS refresh in seconds. Max value is 7 days as per https://datatracker.ietf.org/doc/html/rfc8767
	RefreshInterval *int64

	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	Segment *SchemaviewsObjectRefType

	// x-displayName: "Select Site or Virtual Site or Cloud Edge" This message defines reference to site or virtual site or a
// cloud-re-region object
	SiteLocator *ViewsSiteRegionLocator
}

// OriginPoolOriginServerType - Various options to specify origin server
type OriginPoolOriginServerType struct {
	// Specify origin server with Hashi Corp Consul service name and site information
	ConsulService *OriginPoolOriginServerConsulService

	// Specify origin server with a reference to endpoint object
	CustomEndpointObject *OriginPoolOriginServerCustomEndpoint

	// Specify origin server with K8s service name and site information
	K8SService *OriginPoolOriginServerK8SService

	// Add Labels for this origin server, these labels can be used to form subset.
// Example: "value"
	Labels any

	// Specify origin server with private or public IP address and site information
	PrivateIP *OriginPoolOriginServerPrivateIP

	// Specify origin server with private or public DNS name and site information
	PrivateName *OriginPoolOriginServerPrivateName

	// Specify origin server with public IP address
	PublicIP *OriginPoolOriginServerPublicIP

	// Specify origin server with public DNS name
	PublicName *OriginPoolOriginServerPublicName

	// Specify origin server with IP on Virtual Network
	VnPrivateIP *OriginPoolOriginServerVirtualNetworkIP

	// Specify origin server with DNS name on Virtual Network
	VnPrivateName *OriginPoolOriginServerVirtualNetworkName
}

// OriginPoolOriginServerVirtualNetworkIP - Specify origin server with IP on Virtual Network
type OriginPoolOriginServerVirtualNetworkIP struct {
	// Exclusive with [] IPV4 address
// Example: "1.1.1.1"
// Validation Rules: ves.io.schema.rules.string.ipv4: true
	IP *string

	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	VirtualNetwork *SchemaviewsObjectRefType
}

// OriginPoolOriginServerVirtualNetworkName - Specify origin server with DNS name on Virtual Network
type OriginPoolOriginServerVirtualNetworkName struct {
	// DNS Name
// Example: "value"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true
	DNSName *string

	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	PrivateNetwork *SchemaviewsObjectRefType
}

// OriginPoolReplaceRequest - This is the input message of the 'Replace' RPC
type OriginPoolReplaceRequest struct {
	// ObjectReplaceMetaType is metadata that can be specified in Replace request of an object.
	Metadata *SchemaObjectReplaceMetaType

	// Shape of the origin pool create specification
	Spec *ViewsoriginPoolReplaceSpecType
}

type OriginPoolSpecType struct {
	// Shape of the origin pool specification
	GcSpec *ViewsoriginPoolGlobalSpecType
}

// OriginPoolSubsets - Configure subset options for origin pool
type OriginPoolSubsets struct {
	// This can be used for messages where no values are needed
	AnyEndpoint any

	// Default Subset definition
	DefaultSubset *OriginPoolDefaultSubset

	// List of subset class. Subsets class is defined using list of keys. Every unique combination of values of these keys form
// a subset withing the class.
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.repeated.max_items: 32
	EndpointSubsets any

	// This can be used for messages where no values are needed
	FailRequest any
}

// OriginPoolTLSCertificatesType - TLS Certificates
type OriginPoolTLSCertificatesType struct {
	// TLS Certificates
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.repeated.maxitems: 16 ves.io.schema.rules.repeated.minitems:
// 1
	TLSCertificates any
}

// OriginPoolUpstreamTLSParameters - Upstream TLS Parameters
type OriginPoolUpstreamTLSParameters struct {
	// This can be used for messages where no values are needed
	DisableSni any

	// This can be used for messages where no values are needed
	NoMtls any

	// This can be used for messages where no values are needed
	SkipServerVerification any

	// Exclusive with [disablesni usehostheaderas_sni] SNI value to be used.
// Validation Rules: ves.io.schema.rules.string.hostname: true ves.io.schema.rules.string.max_len: 256
	Sni *string

	// This defines various options to configure TLS configuration parameters
	TLSConfig *ViewsTLSConfig

	// This can be used for messages where no values are needed
	UseHostHeaderAsSni any

	// TLS Certificates
	UseMtls *OriginPoolTLSCertificatesType

	// Upstream TLS Validation Context
	UseServerVerification *OriginPoolUpstreamTLSValidationContext

	// This can be used for messages where no values are needed
	VolterraTrustedCa any
}

// OriginPoolUpstreamTLSValidationContext - Upstream TLS Validation Context
type OriginPoolUpstreamTLSValidationContext struct {
	// Exclusive with [] Inline Root CA certificate for verification of Server's certificate
// Validation Rules: ves.io.schema.rules.string.maxbytes: 131072 ves.io.schema.rules.string.minbytes: 1 ves.io.schema.rules.string.truststore_url:
// true
	TrustedCaURL *string
}

// ProtobufAny - Any contains an arbitrary serialized protocol buffer message along with a URL that describes the type of
// the serialized message.
// Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods
// of the Any type.
// Example 1: Pack and unpack a message in C++.
// Foo foo = ...;
// Any any;
// any.PackFrom(foo);
// ...
// if (any.UnpackTo(&foo)) {
// ...
// }
// Example 2: Pack and unpack a message in Java.
// Foo foo = ...;
// Any any = Any.pack(foo);
// ...
// if (any.is(Foo.class)) {
// foo = any.unpack(Foo.class);
// }
// Example 3: Pack and unpack a message in Python.
// foo = Foo(...)
// any = Any()
// any.Pack(foo)
// ...
// if any.Is(Foo.DESCRIPTOR):
// any.Unpack(foo)
// ...
// Example 4: Pack and unpack a message in Go
// foo := &pb.Foo{...}
// any, err := ptypes.MarshalAny(foo)
// ...
// foo := &pb.Foo{}
// if err := ptypes.UnmarshalAny(any, foo); err != nil {
// ...
// }
// The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL
// and the unpack methods only use the fully qualified type name after the last '/'
// in the type URL, for example "foo.bar.com/x/y.z" will yield type name "y.z".
// JSON
// The JSON representation of an Any value uses the regular representation of the deserialized, embedded message, with an
// additional field @type which contains the type URL. Example:
// package google.profile;
// message Person {
// string first_name = 1;
// string last_name = 2;
// }
// {
// "@type": "type.googleapis.com/google.profile.Person",
// "firstName": <string>,
// "lastName": <string>
// }
// If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding
// a fieldvalue which holds the custom JSON in addition to the @typefield.
// Example (for message [google.protobuf.Duration][]):
// {
// "@type": "type.googleapis.com/google.protobuf.Duration",
// "value": "1.212s"
// }
type ProtobufAny struct {
	// A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain
// at least one "/" character. The last segment of the URL's path must represent
// the fully qualified name of the type (as inpath/google.protobuf.Duration). The name should be in a canonical form (e.g.,
// leading "." is not accepted).
// In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However,
// for URLs which use the scheme http, https, or no scheme, one can optionally
// set up a type server that maps type URLs to message definitions as follows:
// * If no scheme is provided, https is assumed.
// * An HTTP GET on the URL must yield a [google.protobuf.Type][] value in binary format, or produce an error.
// * Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any
// lookup. Therefore, binary compatibility needs to be preserved on changes to
// types. (Use versioned type names to manage breaking changes.)
// Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs
// beginning with type.googleapis.com.
// Schemes other than http, https (or the empty scheme) might be used with implementation specific semantics.
	TypeURL *string

	// Must be a valid serialized protocol buffer of the above specified type.
	Value []byte
}

// SchemaBlindfoldSecretInfoType - BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management
type SchemaBlindfoldSecretInfoType struct {
	// Name of the Secret Management Access object that contains information about the backend Secret Management service.
// Example: "value"
	DecryptionProvider *string

	// Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https
// location
// Example: "string:///U2VjcmV0SW5mb3JtYXRpb24="
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.string.uri_ref: true
	Location *string

	// Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field
// needs to be provided only if the url scheme is not string:///
// Example: "value"
	StoreProvider *string
}

// SchemaClearSecretInfoType - ClearSecretInfoType specifies information about the Secret that is not encrypted.
type SchemaClearSecretInfoType struct {
	// Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field
// needs to be provided only if the url scheme is not string:///
// Example: "box-provider"
	Provider *string

	// URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64
// format. When asked for this secret, caller will get Secret bytes after Base64
// decoding.
// Example: "string:///U2VjcmV0SW5mb3JtYXRpb24="
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.string.maxbytes: 131072 ves.io.schema.rules.string.uriref:
// true
	URL *string
}

// SchemaErrorType - Information about a error in API operation
type SchemaErrorType struct {
	// Union of all possible error-codes from system
// * EOK: No error
// * EPERMS: Permissions error
// * EBADINPUT: Input is not correct
// * ENOTFOUND: Not found
// * EEXISTS: Already exists
// * EUNKNOWN: Unknown/catchall error
// * ESERIALIZE: Error in serializing/de-serializing
// * EINTERNAL: Server error
// * EPARTIAL: Partial error
	Code *SchemaErrorCode

	// Any contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized
// message.
// Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods
// of the Any type.
// Example 1: Pack and unpack a message in C++.
// Foo foo = ...;
// Any any;
// any.PackFrom(foo);
// ...
// if (any.UnpackTo(&foo)) {
// ...
// }
// Example 2: Pack and unpack a message in Java.
// Foo foo = ...;
// Any any = Any.pack(foo);
// ...
// if (any.is(Foo.class)) {
// foo = any.unpack(Foo.class);
// }
// Example 3: Pack and unpack a message in Python.
// foo = Foo(...)
// any = Any()
// any.Pack(foo)
// ...
// if any.Is(Foo.DESCRIPTOR):
// any.Unpack(foo)
// ...
// Example 4: Pack and unpack a message in Go
// foo := &pb.Foo{...}
// any, err := ptypes.MarshalAny(foo)
// ...
// foo := &pb.Foo{}
// if err := ptypes.UnmarshalAny(any, foo); err != nil {
// ...
// }
// The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL
// and the unpack methods only use the fully qualified type name after the last '/'
// in the type URL, for example "foo.bar.com/x/y.z" will yield type name "y.z".
// JSON
// The JSON representation of an Any value uses the regular representation of the deserialized, embedded message, with an
// additional field @type which contains the type URL. Example:
// package google.profile;
// message Person {
// string first_name = 1;
// string last_name = 2;
// }
// {
// "@type": "type.googleapis.com/google.profile.Person",
// "firstName": <string>,
// "lastName": <string>
// }
// If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding
// a fieldvalue which holds the custom JSON in addition to the @typefield.
// Example (for message [google.protobuf.Duration][]):
// {
// "@type": "type.googleapis.com/google.protobuf.Duration",
// "value": "1.212s"
// }
	ErrorObj *ProtobufAny

	// A human readable string of the error
// Example: "value"
	Message *string
}

// SchemaHashAlgorithms - Specifies the hash algorithms to be used
type SchemaHashAlgorithms struct {
	// Ordered list of hash algorithms to be used.
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.repeated.maxitems: 4 ves.io.schema.rules.repeated.minitems:
// 1 ves.io.schema.rules.repeated.unique: true
	HashAlgorithms any
}

// SchemaHeaderTransformationType - Header Transformation options for HTTP/1.1 request/response headers
type SchemaHeaderTransformationType struct {
	// This can be used for messages where no values are needed
	DefaultHeaderTransformation any

	// This can be used for messages where no values are needed
	ProperCaseHeaderTransformation any
}

// SchemaInitializerType - Initializer is information about an initializer that has not yet completed.
type SchemaInitializerType struct {
	// name of the service that is responsible for initializing this object.
	Name *string
}

// SchemaInitializersType - Initializers tracks the progress of initialization of a configuration object
type SchemaInitializersType struct {
	// Pending is a list of initializers that must execute in order before this object is initialized. When the last pending initializer
// is removed, and no failing result is set, the initializers struct will
// be set to nil and the object is considered as initialized and visible to all clients.
	Pending any

	// Status is a return value for calls that don't return other objects.
	Result *SchemaStatusType
}

// SchemaLabelSelectorType - x-displayName: "Label Selector" This type can be used to establish a 'selector reference' from
// one object(called selector) to a set of other objects(called selectees) based on the value of
// expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects. A
// null label selector matches no objects. Label selector is immutable. expressions
// is a list of strings of label selection expression. Each string has "," separated values which are "AND" and all strings
// are logically "OR". BNF for expression string ::= | "," ::= [!] KEY [ | ] ::=
// "" | ::= | ::= "notin" ::= "in" ::= "(" ")" ::= VALUE | VALUE "," ::= ["="|"=="|"!="] VALUE
type SchemaLabelSelectorType struct {
	// x-displayName: "Selector Expression" x-required x-example: "region in (us-west1, us-west2),tier in (staging)" expressions
// contains the kubernetes style label expression for selections.
	Expressions any
}

// SchemaObjectCreateMetaType - ObjectCreateMetaType is metadata that can be specified in Create request of an object.
type SchemaObjectCreateMetaType struct {
	// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve
// arbitrary metadata. They are not queryable and should be preserved when
// modifying objects.
// Example: "value"
// Validation Rules: ves.io.schema.rules.map.keys.string.maxlen: 64 ves.io.schema.rules.map.keys.string.minlen: 1 ves.io.schema.rules.map.values.string.maxlen:
// 1024
// ves.io.schema.rules.map.values.string.minlen: 1
	Annotations any

	// Human readable description for the object
// Example: "Virtual Host for acmecorp website"
	Description *string

	// A value of true will administratively disable the object
// Example: "true"
	Disable *bool

	// Map of string keys and values that can be used to organize and categorize (scope and select) objects as chosen by the user.
// Values specified here will be used by selector expression
// Example: "value"
	Labels any

	// This is the name of configuration object. It has to be unique within the namespace. It can only be specified during create
// API and cannot be changed during replace API. The value of name has to follow
// DNS-1035 format.
// Example: "acmecorp-web"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true
	Name *string

	// This defines the workspace within which each the configuration object is to be created. Must be a DNS_LABEL format. For
// a namespace object itself, namespace value will be ""
// Example: "staging"
	Namespace *string
}

// SchemaObjectGetMetaType - ObjectGetMetaType is metadata that can be specified in Get/Create response of an object.
type SchemaObjectGetMetaType struct {
	// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve
// arbitrary metadata. They are not queryable and should be preserved when
// modifying objects.
// Example: "value"
// Validation Rules: ves.io.schema.rules.map.keys.string.maxlen: 64 ves.io.schema.rules.map.keys.string.minlen: 1 ves.io.schema.rules.map.values.string.maxlen:
// 1024
// ves.io.schema.rules.map.values.string.minlen: 1
	Annotations any

	// Human readable description for the object
// Example: "Virtual Host for acmecorp website"
	Description *string

	// A value of true will administratively disable the object
// Example: "true"
	Disable *bool

	// Map of string keys and values that can be used to organize and categorize (scope and select) objects as chosen by the user.
// Values specified here will be used by selector expression
// Example: "value"
	Labels any

	// This is the name of configuration object. It has to be unique within the namespace. It can only be specified during create
// API and cannot be changed during replace API. The value of name has to follow
// DNS-1035 format.
// Example: "acmecorp-web"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true
	Name *string

	// This defines the workspace within which each the configuration object is to be created. Must be a DNS_LABEL format. For
// a namespace object itself, namespace value will be ""
// Example: "staging"
	Namespace *string
}

// SchemaObjectMetaType - ObjectMetaType is metadata(common attributes) of an object that all configuration objects will have.
// The information in this type can be specified by user during create and replace APIs.
type SchemaObjectMetaType struct {
	// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve
// arbitrary metadata. They are not queryable and should be preserved when
// modifying objects.
// Example: "value"
// Validation Rules: ves.io.schema.rules.map.keys.string.maxlen: 64 ves.io.schema.rules.map.keys.string.minlen: 1 ves.io.schema.rules.map.values.string.maxlen:
// 1024
// ves.io.schema.rules.map.values.string.minlen: 1
	Annotations any

	// Human readable description for the object
// Example: "Virtual Host for acmecorp website"
	Description *string

	// A value of true will administratively disable the object
// Example: "true"
	Disable *bool

	// Map of string keys and values that can be used to organize and categorize (scope and select) objects as chosen by the user.
// Values specified here will be used by selector expression
// Example: "value"
	Labels any

	// This is the name of configuration object. It has to be unique within the namespace. It can only be specified during create
// API and cannot be changed during replace API. The value of name has to follow
// DNS-1035 format.
// Example: "acmecorp-web"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true
	Name *string

	// This defines the workspace within which each the configuration object is to be created. Must be a DNS_LABEL format. For
// a namespace object itself, namespace value will be ""
// Example: "staging"
	Namespace *string

	// uid is the unique in time and space value for this object. Object create will fail if provided by the client and the value
// exists in the system. Typically generated by the server on successful
// creation of an object and is not allowed to change once populated. Shadowed by SystemObjectMeta's uid field.
// Example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	UID *string
}

// SchemaObjectReplaceMetaType - ObjectReplaceMetaType is metadata that can be specified in Replace request of an object.
type SchemaObjectReplaceMetaType struct {
	// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve
// arbitrary metadata. They are not queryable and should be preserved when
// modifying objects.
// Example: "value"
// Validation Rules: ves.io.schema.rules.map.keys.string.maxlen: 64 ves.io.schema.rules.map.keys.string.minlen: 1 ves.io.schema.rules.map.values.string.maxlen:
// 1024
// ves.io.schema.rules.map.values.string.minlen: 1
	Annotations any

	// Human readable description for the object
// Example: "Virtual Host for acmecorp website"
	Description *string

	// A value of true will administratively disable the object
// Example: "true"
	Disable *bool

	// Map of string keys and values that can be used to organize and categorize (scope and select) objects as chosen by the user.
// Values specified here will be used by selector expression
// Example: "value"
	Labels any

	// This is the name of configuration object. It has to be unique within the namespace. It can only be specified during create
// API and cannot be changed during replace API. The value of name has to follow
// DNS-1035 format.
// Example: "acmecorp-web"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true
	Name *string

	// This defines the workspace within which each the configuration object is to be created. Must be a DNS_LABEL format. For
// a namespace object itself, namespace value will be ""
// Example: "staging"
	Namespace *string
}

// SchemaSecretType - SecretType is used in an object to indicate a sensitive/confidential field
type SchemaSecretType struct {
	// BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management
	BlindfoldSecretInfo *SchemaBlindfoldSecretInfoType

	// ClearSecretInfoType specifies information about the Secret that is not encrypted.
	ClearSecretInfo *SchemaClearSecretInfoType
}

// SchemaStatusType - Status is a return value for calls that don't return other objects.
type SchemaStatusType struct {
	// Suggested HTTP return code for this status, 0 if not set.
// Example: "0"
	Code *int32

	// A human-readable description of why this operation is in the "Failure" status. If this value is empty there is no information
// available.
// Example: "value"
	Reason *string

	// Status of the operation. One of: "Success" or "Failure".
// Example: "value"
	Status *string
}

// SchemaSystemObjectGetMetaType - SystemObjectGetMetaType is metadata generated or populated by the system for all persisted
// objects and cannot be updated directly by users.
type SchemaSystemObjectGetMetaType struct {
	// CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be
// set in happens-before order across separate operations. Clients may not set this
// value. It is represented in RFC3339 form and is in UTC.
	CreationTimestamp *time.Time

	// A value identifying the class of the user or service which created this configuration object.
// Example: "value"
	CreatorClass *string

	// A value identifying the exact user or service that created this configuration object
// Example: "value"
	CreatorID *string

	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when
// a graceful deletion is requested by the user, and is not directly settable by a
// client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after
// the time in this field, once the finalizers list is empty. As long as the
// finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or
// be set further into the future, although it may be shortened or the resource may
// be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
// by sending a graceful termination signal to the containers in the pod. After
// that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the
// pod from the API. In the presence of network partitions, this object may still
// exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated.
// If not set, graceful deletion of the object has not been requested.
// Populated by the system when a graceful deletion is requested. Read-only.
	DeletionTimestamp *time.Time

	// Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component
// that will remove the entry from the list. If the deletionTimestamp of the object
// is non-nil, entries in this list can only be removed.
// Example: "value"
	Finalizers any

	// Initializers tracks the progress of initialization of a configuration object
	Initializers *SchemaInitializersType

	// Map of string keys and values that can be used to organize and categorize (scope and select) objects as chosen by the operator
// or software. Values here can be interpreted by software(backend or
// frontend) to enable certain behavior e.g. things marked as soft-deleted(restorable).
// Example: "'ves.io/soft-deleted''true'"
	Labels any

	// ModificationTimestamp is a timestamp representing the server time when this object was last modified.
	ModificationTimestamp *time.Time

	// Unique index for the object. Some objects need a unique integer index to be allocated for each object type. This field
// will be populated for all objects that need it and will be zero otherwise.
// Example: "0"
	ObjectIndex *int64

	// ViewRefType represents a reference to a view
	OwnerView *SchemaViewRefType

	// Tenant to which this configuration object belongs to. The value for this is found from presented credentials.
// Example: "acmecorp"
	Tenant *string

	// uid is the unique in time and space value for this object. It is generated by the server on successful creation of an object
// and is not allowed to change on Replace API. The value of is taken from uid
// field of ObjectMetaType, if provided.
// Example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	UID *string
}

// SchemaSystemObjectMetaType - SystemObjectMetaType is metadata generated or populated by the system for all persisted objects
// and cannot be updated directly by users.
type SchemaSystemObjectMetaType struct {
	// CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be
// set in happens-before order across separate operations. Clients may not set this
// value. It is represented in RFC3339 form and is in UTC.
	CreationTimestamp *time.Time

	// A value identifying the class of the user or service which created this configuration object.
// Example: "value"
	CreatorClass *string

	// This can used by the creator of the object for later audit for e.g. by storing the version identifying information of the
// object so at future it can be determined if version present at remote end is
// current or stale.
// Example: "value"
	CreatorCookie *string

	// A value identifying the exact user or service that created this configuration object
// Example: "value"
	CreatorID *string

	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when
// a graceful deletion is requested by the user, and is not directly settable by a
// client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after
// the time in this field, once the finalizers list is empty. As long as the
// finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or
// be set further into the future, although it may be shortened or the resource may
// be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
// by sending a graceful termination signal to the containers in the pod. After
// that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the
// pod from the API. In the presence of network partitions, this object may still
// exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated.
// If not set, graceful deletion of the object has not been requested.
// Populated by the system when a graceful deletion is requested. Read-only.
	DeletionTimestamp *time.Time

	// Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component
// that will remove the entry from the list. If the deletionTimestamp of the object
// is non-nil, entries in this list can only be removed.
// Example: "value"
	Finalizers any

	// Initializers tracks the progress of initialization of a configuration object
	Initializers *SchemaInitializersType

	// Map of string keys and values that can be used to organize and categorize (scope and select) objects as chosen by the operator
// or software. Values here can be interpreted by software(backend or
// frontend) to enable certain behavior e.g. things marked as soft-deleted(restorable).
// Example: "'ves.io/soft-deleted''true'"
	Labels any

	// ModificationTimestamp is a timestamp representing the server time when this object was last modified.
	ModificationTimestamp *time.Time

	// The namespace this object belongs to. This is populated by the service based on the metadata.namespace field when an object
// is created.
// Validation Rules: ves.io.schema.rules.repeated.max_items: 1
	Namespace any

	// Unique index for the object. Some objects need a unique integer index to be allocated for each object type. This field
// will be populated for all objects that need it and will be zero otherwise.
// Example: "0"
	ObjectIndex *int64

	// ViewRefType represents a reference to a view
	OwnerView *SchemaViewRefType

	// This should be set to true If VES/SRE operator wants to suppress an object from being presented to business-logic of a
// daemon(e.g. due to bad-form/issue-causing Object). This is meant only to be used
// in temporary situations for operational continuity till a fix is rolled out in business-logic.
// Example: "true"
	SreDisable *bool

	// Tenant to which this configuration object belongs to. The value for this is found from presented credentials.
// Example: "acmecorp"
	Tenant *string

	// trace_info holds information(::) of the request doing the object modification. This can be used on the watch side to create
// subsequent spans. This information can be used to co-relate activities
// across services (modulo state compression) for a synchronous API.
// Example: "value"
	TraceInfo *string

	// uid is the unique in time and space value for this object. It is generated by the server on successful creation of an object
// and is not allowed to change on Replace API. The value of is taken from uid
// field of ObjectMetaType, if provided.
// Example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	UID *string

	// Indicate origin of this object.
	VtrpID *string

	// Indicate whether mars deems this object to be stale via graceful restart timer information
	VtrpStale *bool
}

// SchemaTLSCertificateType - Handle to fetch certificate and key
type SchemaTLSCertificateType struct {
	// TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.
// Example: "value"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.string.certificateurl: true ves.io.schema.rules.string.maxbytes:
// 131072 ves.io.schema.rules.string.min_bytes: 1
	CertificateURL *string

	// Specifies the hash algorithms to be used
	CustomHashAlgorithms *SchemaHashAlgorithms

	// Description for the certificate
// Example: "Certificate used in production environment"
	Description *string

	// This can be used for messages where no values are needed
	DisableOcspStapling any

	// SecretType is used in an object to indicate a sensitive/confidential field
	PrivateKey *SchemaSecretType

	// This can be used for messages where no values are needed
	UseSystemDefaults any
}

// SchemaVaultSecretInfoType - x-displayName: "Vault Secret" VaultSecretInfoType specifies information about the Secret managed
// by Hashicorp Vault.
type SchemaVaultSecretInfoType struct {
	// x-displayName: "Key" x-example: "key_pem" Key of the individual secret. Vault Secrets are stored as key-value pair. If
// user is only interested in one value from the map, this field should be set to
// the corresponding key. If not provided entire secret will be returned.
	Key *string

	// x-displayName: "Location" x-required x-example: "v1/data/vhost_key" Path to secret in Vault.
	Location *string

	// x-displayName: "Provider" x-required x-example: "vault-vh-provider" Name of the Secret Management Access object that contains
// information about the backend Vault.
	Provider *string

	// x-displayName: "Secret Encoding" SecretEncodingType defines the encoding type of the secret before handled by the Secret
// Management Service.
// * EncodingNone: x-displayName: "None" No Encoding
// * EncodingBase64: Base64
// x-displayName: "Base64" Base64 encoding
	SecretEncoding *SchemaSecretEncodingType

	// x-displayName: "Version" x-example: "1" Version of the secret to be fetched. As vault secrets are versioned, user can specify
// this field to fetch specific version. If not provided latest version will
// be returned.
	Version *int64
}

// SchemaViewRefType - ViewRefType represents a reference to a view
type SchemaViewRefType struct {
	// Kind of the view object
// Example: "http_proxy"
	Kind *string

	// When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g.
// route's) name.
// Example: "contactus-route"
	Name *string

	// When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g.
// route's) namespace.
// Example: "ns1"
	Namespace *string

	// UID of the view object
// Example: "f3744323-1adf-4aaa-a5dc-0707c1d1bd82"
	UID *string
}

// SchemaWingmanSecretInfoType - x-displayName: "Wingman Secret" WingmanSecretInfoType specifies the handle to the wingman
// secret
type SchemaWingmanSecretInfoType struct {
	// x-displayName: "Name" x-required x-example: "ChargeBack-API-Key" Name of the secret.
	Name *string
}

// SchemaviewsObjectRefType - This type establishes a direct reference from one object(the referrer) to another(the referred).
// Such a reference is in form of tenant/namespace/name
type SchemaviewsObjectRefType struct {
	// When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g.
// route's) name.
// Example: "contacts-route"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.string.maxbytes: 128 ves.io.schema.rules.string.minbytes:
// 1
	Name *string

	// When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g.
// route's) namespace.
// Example: "ns1"
// Validation Rules: ves.io.schema.rules.string.max_bytes: 64
	Namespace *string

	// When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g.
// route's) tenant.
// Example: "acmecorp"
// Validation Rules: ves.io.schema.rules.string.max_bytes: 64
	Tenant *string
}

// ViewsCustomCiphers - This defines TLS protocol config including min/max versions and allowed ciphers
type ViewsCustomCiphers struct {
	// The TLS listener will only support the specified cipher list.
// Example: "TLS_AES_128_GCM_SHA256"
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.repeated.items.string.in: [\"TLSAES128GCMSHA256\",\"TLSAES256GCMSHA384\",\"TLSCHACHA20POLY1305SHA256\",\"TLSECDHEECDSA
// WITHAES128GCMSHA256\",\"TLSECDHEECDSAWITHAES256GCMSHA384\",\"TLSECDHEECDSAWITHCHACHA20POLY1305SHA256\",\"TLSECDHERSAWITHAES128GCMSHA256\",\"TLSECDHERSAWITHAES256GCMSHA384\",\"TLSECDHERSAWITHCHACHA20
// POLY1305SHA256\",\"TLSECDHEECDSAWITHAES128CBCSHA\",\"TLSECDHEECDSAWITHAES256CBCSHA\",\"TLSECDHERSAWITHAES128CBCSHA\",\"TLSECDHERSAWITHAES256CBCSHA\",\"TLSRSAWITHAES128CBCSHA\",\"TLSRSAWITHAES128GCM
// SHA256\",\"TLSRSAWITHAES256CBCSHA\",\"TLSRSAWITHAES256GCM_SHA384\"] ves.io.schema.rules.repeated.unique: true
	CipherSuites any

	// TlsProtocol is enumeration of supported TLS versions
// F5 Distributed Cloud will choose the optimal TLS version.
	MaxVersion *SchemaTLSProtocol

	// TlsProtocol is enumeration of supported TLS versions
// F5 Distributed Cloud will choose the optimal TLS version.
	MinVersion *SchemaTLSProtocol
}

// ViewsSiteLocator - This message defines a reference to a site or virtual site object
type ViewsSiteLocator struct {
	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	Site *SchemaviewsObjectRefType

	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	VirtualSite *SchemaviewsObjectRefType
}

// ViewsSiteRegionLocator - x-displayName: "Select Site or Virtual Site or Cloud Edge" This message defines reference to site
// or virtual site or a cloud-re-region object
type ViewsSiteRegionLocator struct {
	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	CloudReRegion *SchemaviewsObjectRefType

	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	Site *SchemaviewsObjectRefType

	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	VirtualSite *SchemaviewsObjectRefType
}

// ViewsTLSConfig - This defines various options to configure TLS configuration parameters
type ViewsTLSConfig struct {
	// This defines TLS protocol config including min/max versions and allowed ciphers
	CustomSecurity *ViewsCustomCiphers

	// This can be used for messages where no values are needed
	DefaultSecurity any

	// This can be used for messages where no values are needed
	LowSecurity any

	// This can be used for messages where no values are needed
	MediumSecurity any
}

// ViewsoriginPoolCreateSpecType - Shape of the origin pool create specification
type ViewsoriginPoolCreateSpecType struct {
	// Configure Advanced options for origin pool
	AdvancedOptions *OriginPoolAdvancedOptions

	// This can be used for messages where no values are needed
	AutomaticPort any

	// Policy for selection of endpoints from local site/remote site/both
// Consider both remote and local endpoints for load balancing LOCAL_ONLY: Consider only local endpoints for load balancing
// Enable this policy to load balance ONLY among locally discovered endpoints
// Prefer the local endpoints for load balancing. If local endpoints are not present remote endpoints will be considered.
	EndpointSelection *ClusterEndpointSelectionPolicy

	// Exclusive with [sameasendpoint_port] Port used for performing health check
// Validation Rules: ves.io.schema.rules.uint32.lte: 65535
	HealthCheckPort *int64

	// Reference to healthcheck configuration objects
// Validation Rules: ves.io.schema.rules.repeated.max_items: 4
	Healthcheck any

	// This can be used for messages where no values are needed
	LbPort any

	// Different load balancing algorithms supported When a connection to a endpoint in an upstream cluster is required, the load
// balancer uses loadbalancer_algorithm to determine which host is selected.
// * ROUNDROBIN: ROUNDROBIN
// Policy in which each healthy/available upstream endpoint is selected in round robin order.
// * LEASTREQUEST: LEASTREQUEST
// Policy in which loadbalancer picks the upstream endpoint which has the fewest active requests
// * RINGHASH: RINGHASH
// Policy implements consistent hashing to upstream endpoints using ring hash of endpoint names Hash of the incoming request
// is calculated using request hash policy. The ring/modulo hash load balancer
// implements consistent hashing to upstream hosts. The algorithm is based on mapping all hosts onto a circle such that the
// addition or removal of a host from the host set changes only affect 1/N
// requests. This technique is also commonly known as “ketama” hashing. A consistent hashing load balancer is only effective
// when protocol routing is used that specifies a value to hash on. The minimum
// ring size governs the replication factor for each host in the ring. For example, if the minimum ring size is 1024 and there
// are 16 hosts, each host will be replicated 64 times.
// * RANDOM: RANDOM
// Policy in which each available upstream endpoint is selected in random order. The random load balancer selects a random
// healthy host. The random load balancer generally performs better than round
// robin if no health checking policy is configured. Random selection avoids bias towards the host in the set that comes after
// a failed host.
// * LB_OVERRIDE: Load Balancer Override
// Hash policy is taken from from the load balancer which is using this origin pool
	LoadbalancerAlgorithm *ClusterLoadbalancerAlgorithm

	// This can be used for messages where no values are needed
	NoTLS any

	// List of origin servers in this pool
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.repeated.maxitems: 32 ves.io.schema.rules.repeated.minitems:
// 1 ves.io.schema.rules.repeated.unique: true
	OriginServers any

	// Exclusive with [automaticport lbport] Endpoint service is available on this port
// Example: "9080"
// Validation Rules: ves.io.schema.rules.uint32.gte: 1 ves.io.schema.rules.uint32.lte: 65535
	Port *int64

	// This can be used for messages where no values are needed
	SameAsEndpointPort any

	// Upstream TLS Parameters
	UseTLS *OriginPoolUpstreamTLSParameters
}

// ViewsoriginPoolGetSpecType - Shape of the origin pool get specification
type ViewsoriginPoolGetSpecType struct {
	// Configure Advanced options for origin pool
	AdvancedOptions *OriginPoolAdvancedOptions

	// This can be used for messages where no values are needed
	AutomaticPort any

	// Policy for selection of endpoints from local site/remote site/both
// Consider both remote and local endpoints for load balancing LOCAL_ONLY: Consider only local endpoints for load balancing
// Enable this policy to load balance ONLY among locally discovered endpoints
// Prefer the local endpoints for load balancing. If local endpoints are not present remote endpoints will be considered.
	EndpointSelection *ClusterEndpointSelectionPolicy

	// Exclusive with [sameasendpoint_port] Port used for performing health check
// Validation Rules: ves.io.schema.rules.uint32.lte: 65535
	HealthCheckPort *int64

	// Reference to healthcheck configuration objects
// Validation Rules: ves.io.schema.rules.repeated.max_items: 4
	Healthcheck any

	// This can be used for messages where no values are needed
	LbPort any

	// Different load balancing algorithms supported When a connection to a endpoint in an upstream cluster is required, the load
// balancer uses loadbalancer_algorithm to determine which host is selected.
// * ROUNDROBIN: ROUNDROBIN
// Policy in which each healthy/available upstream endpoint is selected in round robin order.
// * LEASTREQUEST: LEASTREQUEST
// Policy in which loadbalancer picks the upstream endpoint which has the fewest active requests
// * RINGHASH: RINGHASH
// Policy implements consistent hashing to upstream endpoints using ring hash of endpoint names Hash of the incoming request
// is calculated using request hash policy. The ring/modulo hash load balancer
// implements consistent hashing to upstream hosts. The algorithm is based on mapping all hosts onto a circle such that the
// addition or removal of a host from the host set changes only affect 1/N
// requests. This technique is also commonly known as “ketama” hashing. A consistent hashing load balancer is only effective
// when protocol routing is used that specifies a value to hash on. The minimum
// ring size governs the replication factor for each host in the ring. For example, if the minimum ring size is 1024 and there
// are 16 hosts, each host will be replicated 64 times.
// * RANDOM: RANDOM
// Policy in which each available upstream endpoint is selected in random order. The random load balancer selects a random
// healthy host. The random load balancer generally performs better than round
// robin if no health checking policy is configured. Random selection avoids bias towards the host in the set that comes after
// a failed host.
// * LB_OVERRIDE: Load Balancer Override
// Hash policy is taken from from the load balancer which is using this origin pool
	LoadbalancerAlgorithm *ClusterLoadbalancerAlgorithm

	// This can be used for messages where no values are needed
	NoTLS any

	// List of origin servers in this pool
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.repeated.maxitems: 32 ves.io.schema.rules.repeated.minitems:
// 1 ves.io.schema.rules.repeated.unique: true
	OriginServers any

	// Exclusive with [automaticport lbport] Endpoint service is available on this port
// Example: "9080"
// Validation Rules: ves.io.schema.rules.uint32.gte: 1 ves.io.schema.rules.uint32.lte: 65535
	Port *int64

	// This can be used for messages where no values are needed
	SameAsEndpointPort any

	// Upstream TLS Parameters
	UseTLS *OriginPoolUpstreamTLSParameters
}

// ViewsoriginPoolGlobalSpecType - Shape of the origin pool specification
type ViewsoriginPoolGlobalSpecType struct {
	// Configure Advanced options for origin pool
	AdvancedOptions *OriginPoolAdvancedOptions

	// This can be used for messages where no values are needed
	AutomaticPort any

	// Policy for selection of endpoints from local site/remote site/both
// Consider both remote and local endpoints for load balancing LOCAL_ONLY: Consider only local endpoints for load balancing
// Enable this policy to load balance ONLY among locally discovered endpoints
// Prefer the local endpoints for load balancing. If local endpoints are not present remote endpoints will be considered.
	EndpointSelection *ClusterEndpointSelectionPolicy

	// Exclusive with [sameasendpoint_port] Port used for performing health check
// Validation Rules: ves.io.schema.rules.uint32.lte: 65535
	HealthCheckPort *int64

	// Reference to healthcheck configuration objects
// Validation Rules: ves.io.schema.rules.repeated.max_items: 4
	Healthcheck any

	// This can be used for messages where no values are needed
	LbPort any

	// Different load balancing algorithms supported When a connection to a endpoint in an upstream cluster is required, the load
// balancer uses loadbalancer_algorithm to determine which host is selected.
// * ROUNDROBIN: ROUNDROBIN
// Policy in which each healthy/available upstream endpoint is selected in round robin order.
// * LEASTREQUEST: LEASTREQUEST
// Policy in which loadbalancer picks the upstream endpoint which has the fewest active requests
// * RINGHASH: RINGHASH
// Policy implements consistent hashing to upstream endpoints using ring hash of endpoint names Hash of the incoming request
// is calculated using request hash policy. The ring/modulo hash load balancer
// implements consistent hashing to upstream hosts. The algorithm is based on mapping all hosts onto a circle such that the
// addition or removal of a host from the host set changes only affect 1/N
// requests. This technique is also commonly known as “ketama” hashing. A consistent hashing load balancer is only effective
// when protocol routing is used that specifies a value to hash on. The minimum
// ring size governs the replication factor for each host in the ring. For example, if the minimum ring size is 1024 and there
// are 16 hosts, each host will be replicated 64 times.
// * RANDOM: RANDOM
// Policy in which each available upstream endpoint is selected in random order. The random load balancer selects a random
// healthy host. The random load balancer generally performs better than round
// robin if no health checking policy is configured. Random selection avoids bias towards the host in the set that comes after
// a failed host.
// * LB_OVERRIDE: Load Balancer Override
// Hash policy is taken from from the load balancer which is using this origin pool
	LoadbalancerAlgorithm *ClusterLoadbalancerAlgorithm

	// This can be used for messages where no values are needed
	NoTLS any

	// List of origin servers in this pool
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.repeated.maxitems: 32 ves.io.schema.rules.repeated.minitems:
// 1 ves.io.schema.rules.repeated.unique: true
	OriginServers any

	// Exclusive with [automaticport lbport] Endpoint service is available on this port
// Example: "9080"
// Validation Rules: ves.io.schema.rules.uint32.gte: 1 ves.io.schema.rules.uint32.lte: 65535
	Port *int64

	// This can be used for messages where no values are needed
	SameAsEndpointPort any

	// Upstream TLS Parameters
	UseTLS *OriginPoolUpstreamTLSParameters

	// This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in
// form of tenant/namespace/name
	ViewInternal *SchemaviewsObjectRefType
}

// ViewsoriginPoolReplaceSpecType - Shape of the origin pool create specification
type ViewsoriginPoolReplaceSpecType struct {
	// Configure Advanced options for origin pool
	AdvancedOptions *OriginPoolAdvancedOptions

	// This can be used for messages where no values are needed
	AutomaticPort any

	// Policy for selection of endpoints from local site/remote site/both
// Consider both remote and local endpoints for load balancing LOCAL_ONLY: Consider only local endpoints for load balancing
// Enable this policy to load balance ONLY among locally discovered endpoints
// Prefer the local endpoints for load balancing. If local endpoints are not present remote endpoints will be considered.
	EndpointSelection *ClusterEndpointSelectionPolicy

	// Exclusive with [sameasendpoint_port] Port used for performing health check
// Validation Rules: ves.io.schema.rules.uint32.lte: 65535
	HealthCheckPort *int64

	// Reference to healthcheck configuration objects
// Validation Rules: ves.io.schema.rules.repeated.max_items: 4
	Healthcheck any

	// This can be used for messages where no values are needed
	LbPort any

	// Different load balancing algorithms supported When a connection to a endpoint in an upstream cluster is required, the load
// balancer uses loadbalancer_algorithm to determine which host is selected.
// * ROUNDROBIN: ROUNDROBIN
// Policy in which each healthy/available upstream endpoint is selected in round robin order.
// * LEASTREQUEST: LEASTREQUEST
// Policy in which loadbalancer picks the upstream endpoint which has the fewest active requests
// * RINGHASH: RINGHASH
// Policy implements consistent hashing to upstream endpoints using ring hash of endpoint names Hash of the incoming request
// is calculated using request hash policy. The ring/modulo hash load balancer
// implements consistent hashing to upstream hosts. The algorithm is based on mapping all hosts onto a circle such that the
// addition or removal of a host from the host set changes only affect 1/N
// requests. This technique is also commonly known as “ketama” hashing. A consistent hashing load balancer is only effective
// when protocol routing is used that specifies a value to hash on. The minimum
// ring size governs the replication factor for each host in the ring. For example, if the minimum ring size is 1024 and there
// are 16 hosts, each host will be replicated 64 times.
// * RANDOM: RANDOM
// Policy in which each available upstream endpoint is selected in random order. The random load balancer selects a random
// healthy host. The random load balancer generally performs better than round
// robin if no health checking policy is configured. Random selection avoids bias towards the host in the set that comes after
// a failed host.
// * LB_OVERRIDE: Load Balancer Override
// Hash policy is taken from from the load balancer which is using this origin pool
	LoadbalancerAlgorithm *ClusterLoadbalancerAlgorithm

	// This can be used for messages where no values are needed
	NoTLS any

	// List of origin servers in this pool
// Required: YES
// Validation Rules: ves.io.schema.rules.message.required: true ves.io.schema.rules.repeated.maxitems: 32 ves.io.schema.rules.repeated.minitems:
// 1 ves.io.schema.rules.repeated.unique: true
	OriginServers any

	// Exclusive with [automaticport lbport] Endpoint service is available on this port
// Example: "9080"
// Validation Rules: ves.io.schema.rules.uint32.gte: 1 ves.io.schema.rules.uint32.lte: 65535
	Port *int64

	// This can be used for messages where no values are needed
	SameAsEndpointPort any

	// Upstream TLS Parameters
	UseTLS *OriginPoolUpstreamTLSParameters
}

