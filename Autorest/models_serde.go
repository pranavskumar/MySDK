//go:build go1.18
// +build go1.18

// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/go@4.0.0-preview.63)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// Code generated by @autorest/go. DO NOT EDIT.

package generated

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type ClusterCircuitBreaker.
func (c ClusterCircuitBreaker) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connection_limit", c.ConnectionLimit)
	populate(objectMap, "max_requests", c.MaxRequests)
	populate(objectMap, "pending_requests", c.PendingRequests)
	populate(objectMap, "priority", c.Priority)
	populate(objectMap, "retries", c.Retries)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterCircuitBreaker.
func (c *ClusterCircuitBreaker) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connection_limit":
				err = unpopulate(val, "ConnectionLimit", &c.ConnectionLimit)
			delete(rawMsg, key)
		case "max_requests":
				err = unpopulate(val, "MaxRequests", &c.MaxRequests)
			delete(rawMsg, key)
		case "pending_requests":
				err = unpopulate(val, "PendingRequests", &c.PendingRequests)
			delete(rawMsg, key)
		case "priority":
				err = unpopulate(val, "Priority", &c.Priority)
			delete(rawMsg, key)
		case "retries":
				err = unpopulate(val, "Retries", &c.Retries)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterEndpointSubsetSelectorType.
func (c ClusterEndpointSubsetSelectorType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "keys", c.Keys)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterEndpointSubsetSelectorType.
func (c *ClusterEndpointSubsetSelectorType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keys":
				err = unpopulate(val, "Keys", &c.Keys)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterHTTP2ProtocolOptions.
func (c ClusterHTTP2ProtocolOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enabled", c.Enabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterHTTP2ProtocolOptions.
func (c *ClusterHTTP2ProtocolOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabled":
				err = unpopulate(val, "Enabled", &c.Enabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterOutlierDetectionType.
func (c ClusterOutlierDetectionType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "base_ejection_time", c.BaseEjectionTime)
	populate(objectMap, "consecutive_5xx", c.Consecutive5Xx)
	populate(objectMap, "consecutive_gateway_failure", c.ConsecutiveGatewayFailure)
	populate(objectMap, "interval", c.Interval)
	populate(objectMap, "max_ejection_percent", c.MaxEjectionPercent)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterOutlierDetectionType.
func (c *ClusterOutlierDetectionType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "base_ejection_time":
				err = unpopulate(val, "BaseEjectionTime", &c.BaseEjectionTime)
			delete(rawMsg, key)
		case "consecutive_5xx":
				err = unpopulate(val, "Consecutive5Xx", &c.Consecutive5Xx)
			delete(rawMsg, key)
		case "consecutive_gateway_failure":
				err = unpopulate(val, "ConsecutiveGatewayFailure", &c.ConsecutiveGatewayFailure)
			delete(rawMsg, key)
		case "interval":
				err = unpopulate(val, "Interval", &c.Interval)
			delete(rawMsg, key)
		case "max_ejection_percent":
				err = unpopulate(val, "MaxEjectionPercent", &c.MaxEjectionPercent)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IoschemaObjectRefType.
func (i IoschemaObjectRefType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", i.Kind)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "namespace", i.Namespace)
	populate(objectMap, "tenant", i.Tenant)
	populate(objectMap, "uid", i.UID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IoschemaObjectRefType.
func (i *IoschemaObjectRefType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &i.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &i.Namespace)
			delete(rawMsg, key)
		case "tenant":
				err = unpopulate(val, "Tenant", &i.Tenant)
			delete(rawMsg, key)
		case "uid":
				err = unpopulate(val, "UID", &i.UID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolAdvancedOptions.
func (o OriginPoolAdvancedOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "auto_http_config", o.AutoHTTPConfig)
	populate(objectMap, "circuit_breaker", o.CircuitBreaker)
	populate(objectMap, "connection_timeout", o.ConnectionTimeout)
	populateAny(objectMap, "default_circuit_breaker", o.DefaultCircuitBreaker)
	populateAny(objectMap, "disable_circuit_breaker", o.DisableCircuitBreaker)
	populateAny(objectMap, "disable_outlier_detection", o.DisableOutlierDetection)
	populateAny(objectMap, "disable_subsets", o.DisableSubsets)
	populate(objectMap, "enable_subsets", o.EnableSubsets)
	populateAny(objectMap, "http1_config", o.HTTP1Config)
	populate(objectMap, "http2_options", o.HTTP2Options)
	populate(objectMap, "http_idle_timeout", o.HTTPIdleTimeout)
	populate(objectMap, "header_transformation_type", o.HeaderTransformationType)
	populateAny(objectMap, "no_panic_threshold", o.NoPanicThreshold)
	populate(objectMap, "outlier_detection", o.OutlierDetection)
	populate(objectMap, "panic_threshold", o.PanicThreshold)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolAdvancedOptions.
func (o *OriginPoolAdvancedOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "auto_http_config":
				err = unpopulate(val, "AutoHTTPConfig", &o.AutoHTTPConfig)
			delete(rawMsg, key)
		case "circuit_breaker":
				err = unpopulate(val, "CircuitBreaker", &o.CircuitBreaker)
			delete(rawMsg, key)
		case "connection_timeout":
				err = unpopulate(val, "ConnectionTimeout", &o.ConnectionTimeout)
			delete(rawMsg, key)
		case "default_circuit_breaker":
				err = unpopulate(val, "DefaultCircuitBreaker", &o.DefaultCircuitBreaker)
			delete(rawMsg, key)
		case "disable_circuit_breaker":
				err = unpopulate(val, "DisableCircuitBreaker", &o.DisableCircuitBreaker)
			delete(rawMsg, key)
		case "disable_outlier_detection":
				err = unpopulate(val, "DisableOutlierDetection", &o.DisableOutlierDetection)
			delete(rawMsg, key)
		case "disable_subsets":
				err = unpopulate(val, "DisableSubsets", &o.DisableSubsets)
			delete(rawMsg, key)
		case "enable_subsets":
				err = unpopulate(val, "EnableSubsets", &o.EnableSubsets)
			delete(rawMsg, key)
		case "http1_config":
				err = unpopulate(val, "HTTP1Config", &o.HTTP1Config)
			delete(rawMsg, key)
		case "http2_options":
				err = unpopulate(val, "HTTP2Options", &o.HTTP2Options)
			delete(rawMsg, key)
		case "http_idle_timeout":
				err = unpopulate(val, "HTTPIdleTimeout", &o.HTTPIdleTimeout)
			delete(rawMsg, key)
		case "header_transformation_type":
				err = unpopulate(val, "HeaderTransformationType", &o.HeaderTransformationType)
			delete(rawMsg, key)
		case "no_panic_threshold":
				err = unpopulate(val, "NoPanicThreshold", &o.NoPanicThreshold)
			delete(rawMsg, key)
		case "outlier_detection":
				err = unpopulate(val, "OutlierDetection", &o.OutlierDetection)
			delete(rawMsg, key)
		case "panic_threshold":
				err = unpopulate(val, "PanicThreshold", &o.PanicThreshold)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolCreateRequest.
func (o OriginPoolCreateRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "metadata", o.Metadata)
	populate(objectMap, "spec", o.Spec)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolCreateRequest.
func (o *OriginPoolCreateRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "metadata":
				err = unpopulate(val, "Metadata", &o.Metadata)
			delete(rawMsg, key)
		case "spec":
				err = unpopulate(val, "Spec", &o.Spec)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolCreateResponse.
func (o OriginPoolCreateResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "metadata", o.Metadata)
	populate(objectMap, "spec", o.Spec)
	populate(objectMap, "system_metadata", o.SystemMetadata)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolCreateResponse.
func (o *OriginPoolCreateResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "metadata":
				err = unpopulate(val, "Metadata", &o.Metadata)
			delete(rawMsg, key)
		case "spec":
				err = unpopulate(val, "Spec", &o.Spec)
			delete(rawMsg, key)
		case "system_metadata":
				err = unpopulate(val, "SystemMetadata", &o.SystemMetadata)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolDefaultSubset.
func (o OriginPoolDefaultSubset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "default_subset", o.DefaultSubset)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolDefaultSubset.
func (o *OriginPoolDefaultSubset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "default_subset":
				err = unpopulate(val, "DefaultSubset", &o.DefaultSubset)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolDeleteRequest.
func (o OriginPoolDeleteRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fail_if_referred", o.FailIfReferred)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "namespace", o.Namespace)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolDeleteRequest.
func (o *OriginPoolDeleteRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fail_if_referred":
				err = unpopulate(val, "FailIfReferred", &o.FailIfReferred)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &o.Namespace)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolGetResponse.
func (o OriginPoolGetResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "create_form", o.CreateForm)
	populateAny(objectMap, "deleted_referred_objects", o.DeletedReferredObjects)
	populateAny(objectMap, "disabled_referred_objects", o.DisabledReferredObjects)
	populate(objectMap, "metadata", o.Metadata)
	populate(objectMap, "object", o.Object)
	populateAny(objectMap, "referring_objects", o.ReferringObjects)
	populate(objectMap, "replace_form", o.ReplaceForm)
	populate(objectMap, "spec", o.Spec)
	populate(objectMap, "system_metadata", o.SystemMetadata)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolGetResponse.
func (o *OriginPoolGetResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "create_form":
				err = unpopulate(val, "CreateForm", &o.CreateForm)
			delete(rawMsg, key)
		case "deleted_referred_objects":
				err = unpopulate(val, "DeletedReferredObjects", &o.DeletedReferredObjects)
			delete(rawMsg, key)
		case "disabled_referred_objects":
				err = unpopulate(val, "DisabledReferredObjects", &o.DisabledReferredObjects)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &o.Metadata)
			delete(rawMsg, key)
		case "object":
				err = unpopulate(val, "Object", &o.Object)
			delete(rawMsg, key)
		case "referring_objects":
				err = unpopulate(val, "ReferringObjects", &o.ReferringObjects)
			delete(rawMsg, key)
		case "replace_form":
				err = unpopulate(val, "ReplaceForm", &o.ReplaceForm)
			delete(rawMsg, key)
		case "spec":
				err = unpopulate(val, "Spec", &o.Spec)
			delete(rawMsg, key)
		case "system_metadata":
				err = unpopulate(val, "SystemMetadata", &o.SystemMetadata)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolListResponse.
func (o OriginPoolListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "errors", o.Errors)
	populateAny(objectMap, "items", o.Items)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolListResponse.
func (o *OriginPoolListResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
				err = unpopulate(val, "Errors", &o.Errors)
			delete(rawMsg, key)
		case "items":
				err = unpopulate(val, "Items", &o.Items)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolListResponseItem.
func (o OriginPoolListResponseItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "annotations", o.Annotations)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "disabled", o.Disabled)
	populate(objectMap, "get_spec", o.GetSpec)
	populateAny(objectMap, "labels", o.Labels)
	populate(objectMap, "metadata", o.Metadata)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "namespace", o.Namespace)
	populate(objectMap, "object", o.Object)
	populate(objectMap, "owner_view", o.OwnerView)
	populate(objectMap, "system_metadata", o.SystemMetadata)
	populate(objectMap, "tenant", o.Tenant)
	populate(objectMap, "uid", o.UID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolListResponseItem.
func (o *OriginPoolListResponseItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
				err = unpopulate(val, "Annotations", &o.Annotations)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "disabled":
				err = unpopulate(val, "Disabled", &o.Disabled)
			delete(rawMsg, key)
		case "get_spec":
				err = unpopulate(val, "GetSpec", &o.GetSpec)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &o.Labels)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &o.Metadata)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &o.Namespace)
			delete(rawMsg, key)
		case "object":
				err = unpopulate(val, "Object", &o.Object)
			delete(rawMsg, key)
		case "owner_view":
				err = unpopulate(val, "OwnerView", &o.OwnerView)
			delete(rawMsg, key)
		case "system_metadata":
				err = unpopulate(val, "SystemMetadata", &o.SystemMetadata)
			delete(rawMsg, key)
		case "tenant":
				err = unpopulate(val, "Tenant", &o.Tenant)
			delete(rawMsg, key)
		case "uid":
				err = unpopulate(val, "UID", &o.UID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolObject.
func (o OriginPoolObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "metadata", o.Metadata)
	populate(objectMap, "spec", o.Spec)
	populate(objectMap, "system_metadata", o.SystemMetadata)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolObject.
func (o *OriginPoolObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "metadata":
				err = unpopulate(val, "Metadata", &o.Metadata)
			delete(rawMsg, key)
		case "spec":
				err = unpopulate(val, "Spec", &o.Spec)
			delete(rawMsg, key)
		case "system_metadata":
				err = unpopulate(val, "SystemMetadata", &o.SystemMetadata)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerConsulService.
func (o OriginPoolOriginServerConsulService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "inside_network", o.InsideNetwork)
	populateAny(objectMap, "outside_network", o.OutsideNetwork)
	populate(objectMap, "service_name", o.ServiceName)
	populate(objectMap, "site_locator", o.SiteLocator)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerConsulService.
func (o *OriginPoolOriginServerConsulService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inside_network":
				err = unpopulate(val, "InsideNetwork", &o.InsideNetwork)
			delete(rawMsg, key)
		case "outside_network":
				err = unpopulate(val, "OutsideNetwork", &o.OutsideNetwork)
			delete(rawMsg, key)
		case "service_name":
				err = unpopulate(val, "ServiceName", &o.ServiceName)
			delete(rawMsg, key)
		case "site_locator":
				err = unpopulate(val, "SiteLocator", &o.SiteLocator)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerCustomEndpoint.
func (o OriginPoolOriginServerCustomEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "endpoint", o.Endpoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerCustomEndpoint.
func (o *OriginPoolOriginServerCustomEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endpoint":
				err = unpopulate(val, "Endpoint", &o.Endpoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerK8SService.
func (o OriginPoolOriginServerK8SService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "inside_network", o.InsideNetwork)
	populateAny(objectMap, "outside_network", o.OutsideNetwork)
	populate(objectMap, "service_name", o.ServiceName)
	populate(objectMap, "site_locator", o.SiteLocator)
	populateAny(objectMap, "vk8s_networks", o.Vk8SNetworks)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerK8SService.
func (o *OriginPoolOriginServerK8SService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inside_network":
				err = unpopulate(val, "InsideNetwork", &o.InsideNetwork)
			delete(rawMsg, key)
		case "outside_network":
				err = unpopulate(val, "OutsideNetwork", &o.OutsideNetwork)
			delete(rawMsg, key)
		case "service_name":
				err = unpopulate(val, "ServiceName", &o.ServiceName)
			delete(rawMsg, key)
		case "site_locator":
				err = unpopulate(val, "SiteLocator", &o.SiteLocator)
			delete(rawMsg, key)
		case "vk8s_networks":
				err = unpopulate(val, "Vk8SNetworks", &o.Vk8SNetworks)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerPrivateIP.
func (o OriginPoolOriginServerPrivateIP) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ip", o.IP)
	populateAny(objectMap, "inside_network", o.InsideNetwork)
	populateAny(objectMap, "outside_network", o.OutsideNetwork)
	populate(objectMap, "site_locator", o.SiteLocator)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerPrivateIP.
func (o *OriginPoolOriginServerPrivateIP) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ip":
				err = unpopulate(val, "IP", &o.IP)
			delete(rawMsg, key)
		case "inside_network":
				err = unpopulate(val, "InsideNetwork", &o.InsideNetwork)
			delete(rawMsg, key)
		case "outside_network":
				err = unpopulate(val, "OutsideNetwork", &o.OutsideNetwork)
			delete(rawMsg, key)
		case "site_locator":
				err = unpopulate(val, "SiteLocator", &o.SiteLocator)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerPrivateName.
func (o OriginPoolOriginServerPrivateName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dns_name", o.DNSName)
	populateAny(objectMap, "inside_network", o.InsideNetwork)
	populateAny(objectMap, "outside_network", o.OutsideNetwork)
	populate(objectMap, "refresh_interval", o.RefreshInterval)
	populate(objectMap, "site_locator", o.SiteLocator)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerPrivateName.
func (o *OriginPoolOriginServerPrivateName) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dns_name":
				err = unpopulate(val, "DNSName", &o.DNSName)
			delete(rawMsg, key)
		case "inside_network":
				err = unpopulate(val, "InsideNetwork", &o.InsideNetwork)
			delete(rawMsg, key)
		case "outside_network":
				err = unpopulate(val, "OutsideNetwork", &o.OutsideNetwork)
			delete(rawMsg, key)
		case "refresh_interval":
				err = unpopulate(val, "RefreshInterval", &o.RefreshInterval)
			delete(rawMsg, key)
		case "site_locator":
				err = unpopulate(val, "SiteLocator", &o.SiteLocator)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerPublicIP.
func (o OriginPoolOriginServerPublicIP) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ip", o.IP)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerPublicIP.
func (o *OriginPoolOriginServerPublicIP) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ip":
				err = unpopulate(val, "IP", &o.IP)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerPublicName.
func (o OriginPoolOriginServerPublicName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dns_name", o.DNSName)
	populate(objectMap, "refresh_interval", o.RefreshInterval)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerPublicName.
func (o *OriginPoolOriginServerPublicName) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dns_name":
				err = unpopulate(val, "DNSName", &o.DNSName)
			delete(rawMsg, key)
		case "refresh_interval":
				err = unpopulate(val, "RefreshInterval", &o.RefreshInterval)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerSegmentIP.
func (o OriginPoolOriginServerSegmentIP) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ip", o.IP)
	populate(objectMap, "ipv6", o.IPv6)
	populate(objectMap, "segment", o.Segment)
	populate(objectMap, "site_locator", o.SiteLocator)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerSegmentIP.
func (o *OriginPoolOriginServerSegmentIP) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ip":
				err = unpopulate(val, "IP", &o.IP)
			delete(rawMsg, key)
		case "ipv6":
				err = unpopulate(val, "IPv6", &o.IPv6)
			delete(rawMsg, key)
		case "segment":
				err = unpopulate(val, "Segment", &o.Segment)
			delete(rawMsg, key)
		case "site_locator":
				err = unpopulate(val, "SiteLocator", &o.SiteLocator)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerSegmentName.
func (o OriginPoolOriginServerSegmentName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dns_name", o.DNSName)
	populate(objectMap, "refresh_interval", o.RefreshInterval)
	populate(objectMap, "segment", o.Segment)
	populate(objectMap, "site_locator", o.SiteLocator)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerSegmentName.
func (o *OriginPoolOriginServerSegmentName) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dns_name":
				err = unpopulate(val, "DNSName", &o.DNSName)
			delete(rawMsg, key)
		case "refresh_interval":
				err = unpopulate(val, "RefreshInterval", &o.RefreshInterval)
			delete(rawMsg, key)
		case "segment":
				err = unpopulate(val, "Segment", &o.Segment)
			delete(rawMsg, key)
		case "site_locator":
				err = unpopulate(val, "SiteLocator", &o.SiteLocator)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerType.
func (o OriginPoolOriginServerType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "consul_service", o.ConsulService)
	populate(objectMap, "custom_endpoint_object", o.CustomEndpointObject)
	populate(objectMap, "k8s_service", o.K8SService)
	populateAny(objectMap, "labels", o.Labels)
	populate(objectMap, "private_ip", o.PrivateIP)
	populate(objectMap, "private_name", o.PrivateName)
	populate(objectMap, "public_ip", o.PublicIP)
	populate(objectMap, "public_name", o.PublicName)
	populate(objectMap, "vn_private_ip", o.VnPrivateIP)
	populate(objectMap, "vn_private_name", o.VnPrivateName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerType.
func (o *OriginPoolOriginServerType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "consul_service":
				err = unpopulate(val, "ConsulService", &o.ConsulService)
			delete(rawMsg, key)
		case "custom_endpoint_object":
				err = unpopulate(val, "CustomEndpointObject", &o.CustomEndpointObject)
			delete(rawMsg, key)
		case "k8s_service":
				err = unpopulate(val, "K8SService", &o.K8SService)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &o.Labels)
			delete(rawMsg, key)
		case "private_ip":
				err = unpopulate(val, "PrivateIP", &o.PrivateIP)
			delete(rawMsg, key)
		case "private_name":
				err = unpopulate(val, "PrivateName", &o.PrivateName)
			delete(rawMsg, key)
		case "public_ip":
				err = unpopulate(val, "PublicIP", &o.PublicIP)
			delete(rawMsg, key)
		case "public_name":
				err = unpopulate(val, "PublicName", &o.PublicName)
			delete(rawMsg, key)
		case "vn_private_ip":
				err = unpopulate(val, "VnPrivateIP", &o.VnPrivateIP)
			delete(rawMsg, key)
		case "vn_private_name":
				err = unpopulate(val, "VnPrivateName", &o.VnPrivateName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerVirtualNetworkIP.
func (o OriginPoolOriginServerVirtualNetworkIP) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ip", o.IP)
	populate(objectMap, "virtual_network", o.VirtualNetwork)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerVirtualNetworkIP.
func (o *OriginPoolOriginServerVirtualNetworkIP) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ip":
				err = unpopulate(val, "IP", &o.IP)
			delete(rawMsg, key)
		case "virtual_network":
				err = unpopulate(val, "VirtualNetwork", &o.VirtualNetwork)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolOriginServerVirtualNetworkName.
func (o OriginPoolOriginServerVirtualNetworkName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dns_name", o.DNSName)
	populate(objectMap, "private_network", o.PrivateNetwork)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolOriginServerVirtualNetworkName.
func (o *OriginPoolOriginServerVirtualNetworkName) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dns_name":
				err = unpopulate(val, "DNSName", &o.DNSName)
			delete(rawMsg, key)
		case "private_network":
				err = unpopulate(val, "PrivateNetwork", &o.PrivateNetwork)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolReplaceRequest.
func (o OriginPoolReplaceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "metadata", o.Metadata)
	populate(objectMap, "spec", o.Spec)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolReplaceRequest.
func (o *OriginPoolReplaceRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "metadata":
				err = unpopulate(val, "Metadata", &o.Metadata)
			delete(rawMsg, key)
		case "spec":
				err = unpopulate(val, "Spec", &o.Spec)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolSpecType.
func (o OriginPoolSpecType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "gc_spec", o.GcSpec)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolSpecType.
func (o *OriginPoolSpecType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gc_spec":
				err = unpopulate(val, "GcSpec", &o.GcSpec)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolSubsets.
func (o OriginPoolSubsets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "any_endpoint", o.AnyEndpoint)
	populate(objectMap, "default_subset", o.DefaultSubset)
	populateAny(objectMap, "endpoint_subsets", o.EndpointSubsets)
	populateAny(objectMap, "fail_request", o.FailRequest)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolSubsets.
func (o *OriginPoolSubsets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "any_endpoint":
				err = unpopulate(val, "AnyEndpoint", &o.AnyEndpoint)
			delete(rawMsg, key)
		case "default_subset":
				err = unpopulate(val, "DefaultSubset", &o.DefaultSubset)
			delete(rawMsg, key)
		case "endpoint_subsets":
				err = unpopulate(val, "EndpointSubsets", &o.EndpointSubsets)
			delete(rawMsg, key)
		case "fail_request":
				err = unpopulate(val, "FailRequest", &o.FailRequest)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolTLSCertificatesType.
func (o OriginPoolTLSCertificatesType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "tls_certificates", o.TLSCertificates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolTLSCertificatesType.
func (o *OriginPoolTLSCertificatesType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tls_certificates":
				err = unpopulate(val, "TLSCertificates", &o.TLSCertificates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolUpstreamTLSParameters.
func (o OriginPoolUpstreamTLSParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "disable_sni", o.DisableSni)
	populateAny(objectMap, "no_mtls", o.NoMtls)
	populateAny(objectMap, "skip_server_verification", o.SkipServerVerification)
	populate(objectMap, "sni", o.Sni)
	populate(objectMap, "tls_config", o.TLSConfig)
	populateAny(objectMap, "use_host_header_as_sni", o.UseHostHeaderAsSni)
	populate(objectMap, "use_mtls", o.UseMtls)
	populate(objectMap, "use_server_verification", o.UseServerVerification)
	populateAny(objectMap, "volterra_trusted_ca", o.VolterraTrustedCa)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolUpstreamTLSParameters.
func (o *OriginPoolUpstreamTLSParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disable_sni":
				err = unpopulate(val, "DisableSni", &o.DisableSni)
			delete(rawMsg, key)
		case "no_mtls":
				err = unpopulate(val, "NoMtls", &o.NoMtls)
			delete(rawMsg, key)
		case "skip_server_verification":
				err = unpopulate(val, "SkipServerVerification", &o.SkipServerVerification)
			delete(rawMsg, key)
		case "sni":
				err = unpopulate(val, "Sni", &o.Sni)
			delete(rawMsg, key)
		case "tls_config":
				err = unpopulate(val, "TLSConfig", &o.TLSConfig)
			delete(rawMsg, key)
		case "use_host_header_as_sni":
				err = unpopulate(val, "UseHostHeaderAsSni", &o.UseHostHeaderAsSni)
			delete(rawMsg, key)
		case "use_mtls":
				err = unpopulate(val, "UseMtls", &o.UseMtls)
			delete(rawMsg, key)
		case "use_server_verification":
				err = unpopulate(val, "UseServerVerification", &o.UseServerVerification)
			delete(rawMsg, key)
		case "volterra_trusted_ca":
				err = unpopulate(val, "VolterraTrustedCa", &o.VolterraTrustedCa)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OriginPoolUpstreamTLSValidationContext.
func (o OriginPoolUpstreamTLSValidationContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "trusted_ca_url", o.TrustedCaURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OriginPoolUpstreamTLSValidationContext.
func (o *OriginPoolUpstreamTLSValidationContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "trusted_ca_url":
				err = unpopulate(val, "TrustedCaURL", &o.TrustedCaURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtobufAny.
func (p ProtobufAny) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type_url", p.TypeURL)
	populateByteArray(objectMap, "value", p.Value, func() any {
		return runtime.EncodeByteArray(p.Value, runtime.Base64StdFormat)
	})
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtobufAny.
func (p *ProtobufAny) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type_url":
				err = unpopulate(val, "TypeURL", &p.TypeURL)
			delete(rawMsg, key)
		case "value":
		if val != nil && string(val) != "null" {
				err = runtime.DecodeByteArray(string(val), &p.Value, runtime.Base64StdFormat)
		}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaBlindfoldSecretInfoType.
func (s SchemaBlindfoldSecretInfoType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "decryption_provider", s.DecryptionProvider)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "store_provider", s.StoreProvider)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaBlindfoldSecretInfoType.
func (s *SchemaBlindfoldSecretInfoType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "decryption_provider":
				err = unpopulate(val, "DecryptionProvider", &s.DecryptionProvider)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &s.Location)
			delete(rawMsg, key)
		case "store_provider":
				err = unpopulate(val, "StoreProvider", &s.StoreProvider)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaClearSecretInfoType.
func (s SchemaClearSecretInfoType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provider", s.Provider)
	populate(objectMap, "url", s.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaClearSecretInfoType.
func (s *SchemaClearSecretInfoType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provider":
				err = unpopulate(val, "Provider", &s.Provider)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &s.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaErrorType.
func (s SchemaErrorType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", s.Code)
	populate(objectMap, "error_obj", s.ErrorObj)
	populate(objectMap, "message", s.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaErrorType.
func (s *SchemaErrorType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &s.Code)
			delete(rawMsg, key)
		case "error_obj":
				err = unpopulate(val, "ErrorObj", &s.ErrorObj)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &s.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaHashAlgorithms.
func (s SchemaHashAlgorithms) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "hash_algorithms", s.HashAlgorithms)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaHashAlgorithms.
func (s *SchemaHashAlgorithms) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hash_algorithms":
				err = unpopulate(val, "HashAlgorithms", &s.HashAlgorithms)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaHeaderTransformationType.
func (s SchemaHeaderTransformationType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "default_header_transformation", s.DefaultHeaderTransformation)
	populateAny(objectMap, "proper_case_header_transformation", s.ProperCaseHeaderTransformation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaHeaderTransformationType.
func (s *SchemaHeaderTransformationType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "default_header_transformation":
				err = unpopulate(val, "DefaultHeaderTransformation", &s.DefaultHeaderTransformation)
			delete(rawMsg, key)
		case "proper_case_header_transformation":
				err = unpopulate(val, "ProperCaseHeaderTransformation", &s.ProperCaseHeaderTransformation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaInitializerType.
func (s SchemaInitializerType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaInitializerType.
func (s *SchemaInitializerType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaInitializersType.
func (s SchemaInitializersType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "pending", s.Pending)
	populate(objectMap, "result", s.Result)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaInitializersType.
func (s *SchemaInitializersType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "pending":
				err = unpopulate(val, "Pending", &s.Pending)
			delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &s.Result)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaLabelSelectorType.
func (s SchemaLabelSelectorType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "expressions", s.Expressions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaLabelSelectorType.
func (s *SchemaLabelSelectorType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expressions":
				err = unpopulate(val, "Expressions", &s.Expressions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaObjectCreateMetaType.
func (s SchemaObjectCreateMetaType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "disable", s.Disable)
	populateAny(objectMap, "labels", s.Labels)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "namespace", s.Namespace)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaObjectCreateMetaType.
func (s *SchemaObjectCreateMetaType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
				err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "disable":
				err = unpopulate(val, "Disable", &s.Disable)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &s.Labels)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &s.Namespace)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaObjectGetMetaType.
func (s SchemaObjectGetMetaType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "disable", s.Disable)
	populateAny(objectMap, "labels", s.Labels)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "namespace", s.Namespace)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaObjectGetMetaType.
func (s *SchemaObjectGetMetaType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
				err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "disable":
				err = unpopulate(val, "Disable", &s.Disable)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &s.Labels)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &s.Namespace)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaObjectMetaType.
func (s SchemaObjectMetaType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "disable", s.Disable)
	populateAny(objectMap, "labels", s.Labels)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "namespace", s.Namespace)
	populate(objectMap, "uid", s.UID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaObjectMetaType.
func (s *SchemaObjectMetaType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
				err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "disable":
				err = unpopulate(val, "Disable", &s.Disable)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &s.Labels)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &s.Namespace)
			delete(rawMsg, key)
		case "uid":
				err = unpopulate(val, "UID", &s.UID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaObjectReplaceMetaType.
func (s SchemaObjectReplaceMetaType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "annotations", s.Annotations)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "disable", s.Disable)
	populateAny(objectMap, "labels", s.Labels)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "namespace", s.Namespace)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaObjectReplaceMetaType.
func (s *SchemaObjectReplaceMetaType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
				err = unpopulate(val, "Annotations", &s.Annotations)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "disable":
				err = unpopulate(val, "Disable", &s.Disable)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &s.Labels)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &s.Namespace)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaSecretType.
func (s SchemaSecretType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blindfold_secret_info", s.BlindfoldSecretInfo)
	populate(objectMap, "clear_secret_info", s.ClearSecretInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaSecretType.
func (s *SchemaSecretType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blindfold_secret_info":
				err = unpopulate(val, "BlindfoldSecretInfo", &s.BlindfoldSecretInfo)
			delete(rawMsg, key)
		case "clear_secret_info":
				err = unpopulate(val, "ClearSecretInfo", &s.ClearSecretInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaStatusType.
func (s SchemaStatusType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", s.Code)
	populate(objectMap, "reason", s.Reason)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaStatusType.
func (s *SchemaStatusType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &s.Code)
			delete(rawMsg, key)
		case "reason":
				err = unpopulate(val, "Reason", &s.Reason)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaSystemObjectGetMetaType.
func (s SchemaSystemObjectGetMetaType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "creation_timestamp", s.CreationTimestamp)
	populate(objectMap, "creator_class", s.CreatorClass)
	populate(objectMap, "creator_id", s.CreatorID)
	populateDateTimeRFC3339(objectMap, "deletion_timestamp", s.DeletionTimestamp)
	populateAny(objectMap, "finalizers", s.Finalizers)
	populate(objectMap, "initializers", s.Initializers)
	populateAny(objectMap, "labels", s.Labels)
	populateDateTimeRFC3339(objectMap, "modification_timestamp", s.ModificationTimestamp)
	populate(objectMap, "object_index", s.ObjectIndex)
	populate(objectMap, "owner_view", s.OwnerView)
	populate(objectMap, "tenant", s.Tenant)
	populate(objectMap, "uid", s.UID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaSystemObjectGetMetaType.
func (s *SchemaSystemObjectGetMetaType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creation_timestamp":
				err = unpopulateDateTimeRFC3339(val, "CreationTimestamp", &s.CreationTimestamp)
			delete(rawMsg, key)
		case "creator_class":
				err = unpopulate(val, "CreatorClass", &s.CreatorClass)
			delete(rawMsg, key)
		case "creator_id":
				err = unpopulate(val, "CreatorID", &s.CreatorID)
			delete(rawMsg, key)
		case "deletion_timestamp":
				err = unpopulateDateTimeRFC3339(val, "DeletionTimestamp", &s.DeletionTimestamp)
			delete(rawMsg, key)
		case "finalizers":
				err = unpopulate(val, "Finalizers", &s.Finalizers)
			delete(rawMsg, key)
		case "initializers":
				err = unpopulate(val, "Initializers", &s.Initializers)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &s.Labels)
			delete(rawMsg, key)
		case "modification_timestamp":
				err = unpopulateDateTimeRFC3339(val, "ModificationTimestamp", &s.ModificationTimestamp)
			delete(rawMsg, key)
		case "object_index":
				err = unpopulate(val, "ObjectIndex", &s.ObjectIndex)
			delete(rawMsg, key)
		case "owner_view":
				err = unpopulate(val, "OwnerView", &s.OwnerView)
			delete(rawMsg, key)
		case "tenant":
				err = unpopulate(val, "Tenant", &s.Tenant)
			delete(rawMsg, key)
		case "uid":
				err = unpopulate(val, "UID", &s.UID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaSystemObjectMetaType.
func (s SchemaSystemObjectMetaType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "creation_timestamp", s.CreationTimestamp)
	populate(objectMap, "creator_class", s.CreatorClass)
	populate(objectMap, "creator_cookie", s.CreatorCookie)
	populate(objectMap, "creator_id", s.CreatorID)
	populateDateTimeRFC3339(objectMap, "deletion_timestamp", s.DeletionTimestamp)
	populateAny(objectMap, "finalizers", s.Finalizers)
	populate(objectMap, "initializers", s.Initializers)
	populateAny(objectMap, "labels", s.Labels)
	populateDateTimeRFC3339(objectMap, "modification_timestamp", s.ModificationTimestamp)
	populateAny(objectMap, "namespace", s.Namespace)
	populate(objectMap, "object_index", s.ObjectIndex)
	populate(objectMap, "owner_view", s.OwnerView)
	populate(objectMap, "sre_disable", s.SreDisable)
	populate(objectMap, "tenant", s.Tenant)
	populate(objectMap, "trace_info", s.TraceInfo)
	populate(objectMap, "uid", s.UID)
	populate(objectMap, "vtrp_id", s.VtrpID)
	populate(objectMap, "vtrp_stale", s.VtrpStale)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaSystemObjectMetaType.
func (s *SchemaSystemObjectMetaType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creation_timestamp":
				err = unpopulateDateTimeRFC3339(val, "CreationTimestamp", &s.CreationTimestamp)
			delete(rawMsg, key)
		case "creator_class":
				err = unpopulate(val, "CreatorClass", &s.CreatorClass)
			delete(rawMsg, key)
		case "creator_cookie":
				err = unpopulate(val, "CreatorCookie", &s.CreatorCookie)
			delete(rawMsg, key)
		case "creator_id":
				err = unpopulate(val, "CreatorID", &s.CreatorID)
			delete(rawMsg, key)
		case "deletion_timestamp":
				err = unpopulateDateTimeRFC3339(val, "DeletionTimestamp", &s.DeletionTimestamp)
			delete(rawMsg, key)
		case "finalizers":
				err = unpopulate(val, "Finalizers", &s.Finalizers)
			delete(rawMsg, key)
		case "initializers":
				err = unpopulate(val, "Initializers", &s.Initializers)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &s.Labels)
			delete(rawMsg, key)
		case "modification_timestamp":
				err = unpopulateDateTimeRFC3339(val, "ModificationTimestamp", &s.ModificationTimestamp)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &s.Namespace)
			delete(rawMsg, key)
		case "object_index":
				err = unpopulate(val, "ObjectIndex", &s.ObjectIndex)
			delete(rawMsg, key)
		case "owner_view":
				err = unpopulate(val, "OwnerView", &s.OwnerView)
			delete(rawMsg, key)
		case "sre_disable":
				err = unpopulate(val, "SreDisable", &s.SreDisable)
			delete(rawMsg, key)
		case "tenant":
				err = unpopulate(val, "Tenant", &s.Tenant)
			delete(rawMsg, key)
		case "trace_info":
				err = unpopulate(val, "TraceInfo", &s.TraceInfo)
			delete(rawMsg, key)
		case "uid":
				err = unpopulate(val, "UID", &s.UID)
			delete(rawMsg, key)
		case "vtrp_id":
				err = unpopulate(val, "VtrpID", &s.VtrpID)
			delete(rawMsg, key)
		case "vtrp_stale":
				err = unpopulate(val, "VtrpStale", &s.VtrpStale)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaTLSCertificateType.
func (s SchemaTLSCertificateType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "certificate_url", s.CertificateURL)
	populate(objectMap, "custom_hash_algorithms", s.CustomHashAlgorithms)
	populate(objectMap, "description", s.Description)
	populateAny(objectMap, "disable_ocsp_stapling", s.DisableOcspStapling)
	populate(objectMap, "private_key", s.PrivateKey)
	populateAny(objectMap, "use_system_defaults", s.UseSystemDefaults)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaTLSCertificateType.
func (s *SchemaTLSCertificateType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificate_url":
				err = unpopulate(val, "CertificateURL", &s.CertificateURL)
			delete(rawMsg, key)
		case "custom_hash_algorithms":
				err = unpopulate(val, "CustomHashAlgorithms", &s.CustomHashAlgorithms)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "disable_ocsp_stapling":
				err = unpopulate(val, "DisableOcspStapling", &s.DisableOcspStapling)
			delete(rawMsg, key)
		case "private_key":
				err = unpopulate(val, "PrivateKey", &s.PrivateKey)
			delete(rawMsg, key)
		case "use_system_defaults":
				err = unpopulate(val, "UseSystemDefaults", &s.UseSystemDefaults)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaVaultSecretInfoType.
func (s SchemaVaultSecretInfoType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", s.Key)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "provider", s.Provider)
	populate(objectMap, "secret_encoding", s.SecretEncoding)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaVaultSecretInfoType.
func (s *SchemaVaultSecretInfoType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
				err = unpopulate(val, "Key", &s.Key)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &s.Location)
			delete(rawMsg, key)
		case "provider":
				err = unpopulate(val, "Provider", &s.Provider)
			delete(rawMsg, key)
		case "secret_encoding":
				err = unpopulate(val, "SecretEncoding", &s.SecretEncoding)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaViewRefType.
func (s SchemaViewRefType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", s.Kind)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "namespace", s.Namespace)
	populate(objectMap, "uid", s.UID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaViewRefType.
func (s *SchemaViewRefType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &s.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &s.Namespace)
			delete(rawMsg, key)
		case "uid":
				err = unpopulate(val, "UID", &s.UID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaWingmanSecretInfoType.
func (s SchemaWingmanSecretInfoType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaWingmanSecretInfoType.
func (s *SchemaWingmanSecretInfoType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchemaviewsObjectRefType.
func (s SchemaviewsObjectRefType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "namespace", s.Namespace)
	populate(objectMap, "tenant", s.Tenant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchemaviewsObjectRefType.
func (s *SchemaviewsObjectRefType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &s.Namespace)
			delete(rawMsg, key)
		case "tenant":
				err = unpopulate(val, "Tenant", &s.Tenant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ViewsCustomCiphers.
func (v ViewsCustomCiphers) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "cipher_suites", v.CipherSuites)
	populate(objectMap, "max_version", v.MaxVersion)
	populate(objectMap, "min_version", v.MinVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ViewsCustomCiphers.
func (v *ViewsCustomCiphers) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cipher_suites":
				err = unpopulate(val, "CipherSuites", &v.CipherSuites)
			delete(rawMsg, key)
		case "max_version":
				err = unpopulate(val, "MaxVersion", &v.MaxVersion)
			delete(rawMsg, key)
		case "min_version":
				err = unpopulate(val, "MinVersion", &v.MinVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ViewsSiteLocator.
func (v ViewsSiteLocator) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "site", v.Site)
	populate(objectMap, "virtual_site", v.VirtualSite)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ViewsSiteLocator.
func (v *ViewsSiteLocator) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "site":
				err = unpopulate(val, "Site", &v.Site)
			delete(rawMsg, key)
		case "virtual_site":
				err = unpopulate(val, "VirtualSite", &v.VirtualSite)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ViewsSiteRegionLocator.
func (v ViewsSiteRegionLocator) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cloud_re_region", v.CloudReRegion)
	populate(objectMap, "site", v.Site)
	populate(objectMap, "virtual_site", v.VirtualSite)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ViewsSiteRegionLocator.
func (v *ViewsSiteRegionLocator) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cloud_re_region":
				err = unpopulate(val, "CloudReRegion", &v.CloudReRegion)
			delete(rawMsg, key)
		case "site":
				err = unpopulate(val, "Site", &v.Site)
			delete(rawMsg, key)
		case "virtual_site":
				err = unpopulate(val, "VirtualSite", &v.VirtualSite)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ViewsTLSConfig.
func (v ViewsTLSConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "custom_security", v.CustomSecurity)
	populateAny(objectMap, "default_security", v.DefaultSecurity)
	populateAny(objectMap, "low_security", v.LowSecurity)
	populateAny(objectMap, "medium_security", v.MediumSecurity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ViewsTLSConfig.
func (v *ViewsTLSConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "custom_security":
				err = unpopulate(val, "CustomSecurity", &v.CustomSecurity)
			delete(rawMsg, key)
		case "default_security":
				err = unpopulate(val, "DefaultSecurity", &v.DefaultSecurity)
			delete(rawMsg, key)
		case "low_security":
				err = unpopulate(val, "LowSecurity", &v.LowSecurity)
			delete(rawMsg, key)
		case "medium_security":
				err = unpopulate(val, "MediumSecurity", &v.MediumSecurity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ViewsoriginPoolCreateSpecType.
func (v ViewsoriginPoolCreateSpecType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "advanced_options", v.AdvancedOptions)
	populateAny(objectMap, "automatic_port", v.AutomaticPort)
	populate(objectMap, "endpoint_selection", v.EndpointSelection)
	populate(objectMap, "health_check_port", v.HealthCheckPort)
	populateAny(objectMap, "healthcheck", v.Healthcheck)
	populateAny(objectMap, "lb_port", v.LbPort)
	populate(objectMap, "loadbalancer_algorithm", v.LoadbalancerAlgorithm)
	populateAny(objectMap, "no_tls", v.NoTLS)
	populateAny(objectMap, "origin_servers", v.OriginServers)
	populate(objectMap, "port", v.Port)
	populateAny(objectMap, "same_as_endpoint_port", v.SameAsEndpointPort)
	populate(objectMap, "use_tls", v.UseTLS)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ViewsoriginPoolCreateSpecType.
func (v *ViewsoriginPoolCreateSpecType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "advanced_options":
				err = unpopulate(val, "AdvancedOptions", &v.AdvancedOptions)
			delete(rawMsg, key)
		case "automatic_port":
				err = unpopulate(val, "AutomaticPort", &v.AutomaticPort)
			delete(rawMsg, key)
		case "endpoint_selection":
				err = unpopulate(val, "EndpointSelection", &v.EndpointSelection)
			delete(rawMsg, key)
		case "health_check_port":
				err = unpopulate(val, "HealthCheckPort", &v.HealthCheckPort)
			delete(rawMsg, key)
		case "healthcheck":
				err = unpopulate(val, "Healthcheck", &v.Healthcheck)
			delete(rawMsg, key)
		case "lb_port":
				err = unpopulate(val, "LbPort", &v.LbPort)
			delete(rawMsg, key)
		case "loadbalancer_algorithm":
				err = unpopulate(val, "LoadbalancerAlgorithm", &v.LoadbalancerAlgorithm)
			delete(rawMsg, key)
		case "no_tls":
				err = unpopulate(val, "NoTLS", &v.NoTLS)
			delete(rawMsg, key)
		case "origin_servers":
				err = unpopulate(val, "OriginServers", &v.OriginServers)
			delete(rawMsg, key)
		case "port":
				err = unpopulate(val, "Port", &v.Port)
			delete(rawMsg, key)
		case "same_as_endpoint_port":
				err = unpopulate(val, "SameAsEndpointPort", &v.SameAsEndpointPort)
			delete(rawMsg, key)
		case "use_tls":
				err = unpopulate(val, "UseTLS", &v.UseTLS)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ViewsoriginPoolGetSpecType.
func (v ViewsoriginPoolGetSpecType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "advanced_options", v.AdvancedOptions)
	populateAny(objectMap, "automatic_port", v.AutomaticPort)
	populate(objectMap, "endpoint_selection", v.EndpointSelection)
	populate(objectMap, "health_check_port", v.HealthCheckPort)
	populateAny(objectMap, "healthcheck", v.Healthcheck)
	populateAny(objectMap, "lb_port", v.LbPort)
	populate(objectMap, "loadbalancer_algorithm", v.LoadbalancerAlgorithm)
	populateAny(objectMap, "no_tls", v.NoTLS)
	populateAny(objectMap, "origin_servers", v.OriginServers)
	populate(objectMap, "port", v.Port)
	populateAny(objectMap, "same_as_endpoint_port", v.SameAsEndpointPort)
	populate(objectMap, "use_tls", v.UseTLS)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ViewsoriginPoolGetSpecType.
func (v *ViewsoriginPoolGetSpecType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "advanced_options":
				err = unpopulate(val, "AdvancedOptions", &v.AdvancedOptions)
			delete(rawMsg, key)
		case "automatic_port":
				err = unpopulate(val, "AutomaticPort", &v.AutomaticPort)
			delete(rawMsg, key)
		case "endpoint_selection":
				err = unpopulate(val, "EndpointSelection", &v.EndpointSelection)
			delete(rawMsg, key)
		case "health_check_port":
				err = unpopulate(val, "HealthCheckPort", &v.HealthCheckPort)
			delete(rawMsg, key)
		case "healthcheck":
				err = unpopulate(val, "Healthcheck", &v.Healthcheck)
			delete(rawMsg, key)
		case "lb_port":
				err = unpopulate(val, "LbPort", &v.LbPort)
			delete(rawMsg, key)
		case "loadbalancer_algorithm":
				err = unpopulate(val, "LoadbalancerAlgorithm", &v.LoadbalancerAlgorithm)
			delete(rawMsg, key)
		case "no_tls":
				err = unpopulate(val, "NoTLS", &v.NoTLS)
			delete(rawMsg, key)
		case "origin_servers":
				err = unpopulate(val, "OriginServers", &v.OriginServers)
			delete(rawMsg, key)
		case "port":
				err = unpopulate(val, "Port", &v.Port)
			delete(rawMsg, key)
		case "same_as_endpoint_port":
				err = unpopulate(val, "SameAsEndpointPort", &v.SameAsEndpointPort)
			delete(rawMsg, key)
		case "use_tls":
				err = unpopulate(val, "UseTLS", &v.UseTLS)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ViewsoriginPoolGlobalSpecType.
func (v ViewsoriginPoolGlobalSpecType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "advanced_options", v.AdvancedOptions)
	populateAny(objectMap, "automatic_port", v.AutomaticPort)
	populate(objectMap, "endpoint_selection", v.EndpointSelection)
	populate(objectMap, "health_check_port", v.HealthCheckPort)
	populateAny(objectMap, "healthcheck", v.Healthcheck)
	populateAny(objectMap, "lb_port", v.LbPort)
	populate(objectMap, "loadbalancer_algorithm", v.LoadbalancerAlgorithm)
	populateAny(objectMap, "no_tls", v.NoTLS)
	populateAny(objectMap, "origin_servers", v.OriginServers)
	populate(objectMap, "port", v.Port)
	populateAny(objectMap, "same_as_endpoint_port", v.SameAsEndpointPort)
	populate(objectMap, "use_tls", v.UseTLS)
	populate(objectMap, "view_internal", v.ViewInternal)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ViewsoriginPoolGlobalSpecType.
func (v *ViewsoriginPoolGlobalSpecType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "advanced_options":
				err = unpopulate(val, "AdvancedOptions", &v.AdvancedOptions)
			delete(rawMsg, key)
		case "automatic_port":
				err = unpopulate(val, "AutomaticPort", &v.AutomaticPort)
			delete(rawMsg, key)
		case "endpoint_selection":
				err = unpopulate(val, "EndpointSelection", &v.EndpointSelection)
			delete(rawMsg, key)
		case "health_check_port":
				err = unpopulate(val, "HealthCheckPort", &v.HealthCheckPort)
			delete(rawMsg, key)
		case "healthcheck":
				err = unpopulate(val, "Healthcheck", &v.Healthcheck)
			delete(rawMsg, key)
		case "lb_port":
				err = unpopulate(val, "LbPort", &v.LbPort)
			delete(rawMsg, key)
		case "loadbalancer_algorithm":
				err = unpopulate(val, "LoadbalancerAlgorithm", &v.LoadbalancerAlgorithm)
			delete(rawMsg, key)
		case "no_tls":
				err = unpopulate(val, "NoTLS", &v.NoTLS)
			delete(rawMsg, key)
		case "origin_servers":
				err = unpopulate(val, "OriginServers", &v.OriginServers)
			delete(rawMsg, key)
		case "port":
				err = unpopulate(val, "Port", &v.Port)
			delete(rawMsg, key)
		case "same_as_endpoint_port":
				err = unpopulate(val, "SameAsEndpointPort", &v.SameAsEndpointPort)
			delete(rawMsg, key)
		case "use_tls":
				err = unpopulate(val, "UseTLS", &v.UseTLS)
			delete(rawMsg, key)
		case "view_internal":
				err = unpopulate(val, "ViewInternal", &v.ViewInternal)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ViewsoriginPoolReplaceSpecType.
func (v ViewsoriginPoolReplaceSpecType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "advanced_options", v.AdvancedOptions)
	populateAny(objectMap, "automatic_port", v.AutomaticPort)
	populate(objectMap, "endpoint_selection", v.EndpointSelection)
	populate(objectMap, "health_check_port", v.HealthCheckPort)
	populateAny(objectMap, "healthcheck", v.Healthcheck)
	populateAny(objectMap, "lb_port", v.LbPort)
	populate(objectMap, "loadbalancer_algorithm", v.LoadbalancerAlgorithm)
	populateAny(objectMap, "no_tls", v.NoTLS)
	populateAny(objectMap, "origin_servers", v.OriginServers)
	populate(objectMap, "port", v.Port)
	populateAny(objectMap, "same_as_endpoint_port", v.SameAsEndpointPort)
	populate(objectMap, "use_tls", v.UseTLS)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ViewsoriginPoolReplaceSpecType.
func (v *ViewsoriginPoolReplaceSpecType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "advanced_options":
				err = unpopulate(val, "AdvancedOptions", &v.AdvancedOptions)
			delete(rawMsg, key)
		case "automatic_port":
				err = unpopulate(val, "AutomaticPort", &v.AutomaticPort)
			delete(rawMsg, key)
		case "endpoint_selection":
				err = unpopulate(val, "EndpointSelection", &v.EndpointSelection)
			delete(rawMsg, key)
		case "health_check_port":
				err = unpopulate(val, "HealthCheckPort", &v.HealthCheckPort)
			delete(rawMsg, key)
		case "healthcheck":
				err = unpopulate(val, "Healthcheck", &v.Healthcheck)
			delete(rawMsg, key)
		case "lb_port":
				err = unpopulate(val, "LbPort", &v.LbPort)
			delete(rawMsg, key)
		case "loadbalancer_algorithm":
				err = unpopulate(val, "LoadbalancerAlgorithm", &v.LoadbalancerAlgorithm)
			delete(rawMsg, key)
		case "no_tls":
				err = unpopulate(val, "NoTLS", &v.NoTLS)
			delete(rawMsg, key)
		case "origin_servers":
				err = unpopulate(val, "OriginServers", &v.OriginServers)
			delete(rawMsg, key)
		case "port":
				err = unpopulate(val, "Port", &v.Port)
			delete(rawMsg, key)
		case "same_as_endpoint_port":
				err = unpopulate(val, "SameAsEndpointPort", &v.SameAsEndpointPort)
			delete(rawMsg, key)
		case "use_tls":
				err = unpopulate(val, "UseTLS", &v.UseTLS)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func populateByteArray[T any](m map[string]any, k string, b []T, convert func() any) {
	if azcore.IsNullValue(b) {
		m[k] = nil
	} else if len(b) == 0 {
		return
	} else {
		m[k] = convert()
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

