/*
F5 Distributed Cloud Services API for ves.io.schema.views.origin_pool

Origin pool is a view to create cluster and endpoints that can be used in HTTP loadbalancer or TCP loadbalancer  It will create following child objects  * cluster * endpoints * healthcheck

API version: 
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// ClusterEndpointSelectionPolicy Policy for selection of endpoints from local site/remote site/both  Consider both remote and local endpoints for load balancing LOCAL_ONLY: Consider only local endpoints for load balancing Enable this policy to load balance ONLY among locally discovered endpoints Prefer the local endpoints for load balancing. If local endpoints are not present remote endpoints will be considered.
type ClusterEndpointSelectionPolicy string

// List of clusterEndpointSelectionPolicy
const (
	DISTRIBUTED ClusterEndpointSelectionPolicy = "DISTRIBUTED"
	LOCAL_ONLY ClusterEndpointSelectionPolicy = "LOCAL_ONLY"
	LOCAL_PREFERRED ClusterEndpointSelectionPolicy = "LOCAL_PREFERRED"
)

// All allowed values of ClusterEndpointSelectionPolicy enum
var AllowedClusterEndpointSelectionPolicyEnumValues = []ClusterEndpointSelectionPolicy{
	"DISTRIBUTED",
	"LOCAL_ONLY",
	"LOCAL_PREFERRED",
}

func (v *ClusterEndpointSelectionPolicy) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ClusterEndpointSelectionPolicy(value)
	for _, existing := range AllowedClusterEndpointSelectionPolicyEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ClusterEndpointSelectionPolicy", value)
}

// NewClusterEndpointSelectionPolicyFromValue returns a pointer to a valid ClusterEndpointSelectionPolicy
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewClusterEndpointSelectionPolicyFromValue(v string) (*ClusterEndpointSelectionPolicy, error) {
	ev := ClusterEndpointSelectionPolicy(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ClusterEndpointSelectionPolicy: valid values are %v", v, AllowedClusterEndpointSelectionPolicyEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ClusterEndpointSelectionPolicy) IsValid() bool {
	for _, existing := range AllowedClusterEndpointSelectionPolicyEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to clusterEndpointSelectionPolicy value
func (v ClusterEndpointSelectionPolicy) Ptr() *ClusterEndpointSelectionPolicy {
	return &v
}

type NullableClusterEndpointSelectionPolicy struct {
	value *ClusterEndpointSelectionPolicy
	isSet bool
}

func (v NullableClusterEndpointSelectionPolicy) Get() *ClusterEndpointSelectionPolicy {
	return v.value
}

func (v *NullableClusterEndpointSelectionPolicy) Set(val *ClusterEndpointSelectionPolicy) {
	v.value = val
	v.isSet = true
}

func (v NullableClusterEndpointSelectionPolicy) IsSet() bool {
	return v.isSet
}

func (v *NullableClusterEndpointSelectionPolicy) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableClusterEndpointSelectionPolicy(val *ClusterEndpointSelectionPolicy) *NullableClusterEndpointSelectionPolicy {
	return &NullableClusterEndpointSelectionPolicy{value: val, isSet: true}
}

func (v NullableClusterEndpointSelectionPolicy) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableClusterEndpointSelectionPolicy) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

